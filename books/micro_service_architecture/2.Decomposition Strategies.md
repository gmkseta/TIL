# Decomposition Strategies



# 마이크로 서비스 아키텍처란?

* 예전에는 확장성 신뢰성 보안 등이 목표
* 요즘은 신속/안전하게 소프트웨어를 전달하는 능력도 매우 중요
* 관리성 테스트성 배포성이 높은 아키텍처 스타일

### 1. 소프트웨어 아키텍처의 정의와 중요성

#### 정의

* 렌 바스의 소프트웨어 공학 연구소 정의

  ```
  컴퓨팅 시스템의 소프트웨어 아키텍처는 소프트웨어 엘리먼트와 그들 간의 관계, 그리고 이 둘 속성으로 구성된 시스템을 추론하는 데 필요한 구조의 집합이다.
  ```

* 추상적이긴 하지만 핵심은 여러 파트로의 분해와 이런 파트간의 관계라는 것

* 분해가 중요한 이유

  * 업무와 지식을 분리한다. 덕분에 전문 지식을 보유한 사람들이 함께 생산적으로 어플리케이션 작업을 수행할 수 있음
  * 소프트웨어 엘리먼트가 어떻게 상호작용 하는지 밝힌다.

* 소프트웨어 아키텍처의 4+1 뷰 모델
  * 필립크러첸이 발표한 전설적인 논문
  * 소프트웨어 아키텍처를 바라보는 상이한 4뷰를 정의한다.
  * 각 뷰는 아키텍처의 특정한 측면은 기술하고 특정 소프트웨어 엘리먼트와 그들 사이의 관계로 구성된다.
  * 논리 뷰 - 개발자가 작성한 소프트웨어 엘리먼트, 객체지향이라면 클래스, 패키지가 해당되며 결국 상속, 연관, 의존 등 클래스와 패키지의 관계를 말한다
  * 규현 뷰 - 빌드 시스템의 결과물, 모듈과 컴포넌트로 구성이 된다. (JAR) 모듈간 디펜던시와 컴포넌트 모듈간 조합관계도 이 뷰에 포함
  * 프소세스뷰 - 런타임 컴포넌트 각 엘리먼트는 개별 프로세스이고 IPC는 프로세스간의 관계를 나타냄
  * 배포 뷰 - 프로세스가 머신에 매핑되는 방법. 이 뷰의 엘리먼트는 머신 및 프로세스고 머신간의 관계가 바로 네트워킹이다. 프로세스와 머신 사이의 관계도 이 뷰에서 기술된다.

### 중요성

* 애플리케이션의 요건
  * 해야 할 일을 정의한 기능 요건 
    * 유즈 케이스나 사용자 스토리 포멧으로 기술하는데 아키텍처와 거의 무관하다. 어떤 아키텍처든 진흙탕이든 구현 가능
  * ~성으로 끝나는 서비스 품질 요건
    * 아키텍처가 이 요건을 충족시킬 수 있게 설계해야 하므로 아주 중요하다.
    * 확장성, 신뢰성 같은 런타임 품질
    * 관리성, 테스트성, 배포성 처럼 개발 시점의 품질

### 2. 아키텍처 스타일 개요

* 데이비드 갈란과 메리 쇼의 정의

* ```
  아키텍처 스타일은 체계적인 조직의 관점에서 시스템 군을 정의한다. 좀더 구체적으로 말하면 아키텍처 스타일은 그 스타일로 만든 인스턴스에서 사용 가능한 컴포넌트와 커넥터의 보케블러리 그리고 이들을 조합할 수 있는 제약 조건을 결정한다.
  ```

* 특정 아키텍처 스타일은 엘리먼트(컴포넌트)와 관계(커넥터)의 한전된 팔레트를 제공하며, 이를 토대로 아키텍처의 뷰를 정의할 수 있다.

* 대부분 아키텍처 스타일을 조합해서 사용한다.

* 모놀리식 아키텍처도 규현 뷰를 하나의 컴포넌트로 구성한 아키텍처 스타일이라고 할 수 있다.

* msa는 느슨하게 결합된 여러 서비스로 구성하는 아키텍처 스타일이다.

#### 계층화 아키텍처 스타일 

-mvc 가 대표적인듯?

* 소프트웨어 엘리먼트를 계층별로 구성하는 아키텍처는 전형적인 아키텍처 스타일이다.
* 계층마다 명확히 정의된 역할을 분담하며, 계층 간 디펜던시는 아키텍처로 제한한다.
* 바로 하위에 있는 계층에만 의존하거나, 하위에 위치한 어느 한 계층에만 의존한다.
* 4뷰 다 적용 가능
* 3계층 아키텍처가 계틍화 아키텍처를 논리 뷰에 적용한 사례로 애플리케이션 클래스를 세 계층으로 구성한 아키텍처이다.
  * 표현 계층(presentation layer): 사용자 인터페이스 또는 외부 api가 구현된 계층
  * 비지니스 로직 계층 - 비지니스 로직ㅇ ㅣ구현된 계층
  * 영속화 - persistence 계층 - DB상호 작용 로직이 구현된 계층

* ㅎㅏ지만? 몇가지 흠
  * 표현 계층이 하나뿐이다 ? - 애플리케이션을 호출하는 시스템이 하나뿐일까?
  * 영속화 계층이 하나뿐이다 _ 상호작용하는 db가 정말 하나뿐일까?
  * 비지니스 로직이 영속화 계층에 의존하는 형태로 정의한다 - 이론적으로 이런 디펜던시 때문에 DB없이 비지니스 로직을 테스트하는게 불가능
* 디펜던시를 잘못 나타내는 문제도 있다.
* 비지니스 로직 계층은 인터페이스나 데이터 접근 메서드가 정의된 인터페이스 리포지터리를 정의하고
* 영속화 계층은 리포지터리 인터페이스를 구현한 DAO클래스를 정의한다.
* 결국 실제 디펜던시가 계층화 아키텍처에서 기술된 것과는 정 반대이다.

#### 육각형 아키텍처 스타일

* 논리 뷰를 비지니스로직 중심으로 구성하는ㄱ ㅖ층화 아키텍처의 대안이다.
* 애플리케이션 표현 계층 대신 비지니스 로직을 호출하여 외부에서 들어온 요청을 처리하는 인바운드 어댑터와 
* 영속화 계층 대신 비지니스 로직에 의해 호출되고 외부 애플리ㅋ이션을 호출하는 아웃바운드 어댑터를 둔다.
* 비지니스 로직이 어댑터에 전혀 의존하지 않는다는 것이 이 아키텍처으 ㅣ가장 중요한 특장점이다. 외려 어댑터가 비지니스 로직에 의존한다.
* ![image](https://user-images.githubusercontent.com/72075148/135720746-c9144c76-4a04-4d74-83d7-18bf71b097f8.png)
* 어뎁터는 비니지스 로직 주변을 가싸고 있다.
* 포트처럼 어댑터도 인바운드/아웃바운드 두 종류이다.
* 인바운드는 외부에서 들어온 요청을 인바운드 포트를 호출해서 처리한다 
  *  REST 엔드포인트, mvc 컨트롤러, 메시지 브로커 클라이언트
* 동일한 인바운드 포트를 여러 인바운드 어댑터가 호툴할 수도 있음
* 아웃바운드 어댑터는 비지니스 로직에서 들어온 요청을 외부 어플리케이션/서비스를 호출해서 처리한다.
  * DB작업이 구현된 DAO클래스, 원격 서비스를 호출하는 proxy 클래스
* 아웃바운드 어댑터는 이벤트를 발행하기도 한다.
* 가장 큰 장점은 비지니스 로직에 있던 표현/데이터 접근 로직이 어댑터와 분리되어있기 때문에 비지니스 로직이 표현/데이터 접근 로직 어디에도 의존하지 않는다는 점
* 비지니스 로직만 따로 테스트하기도 쉽고, 현태 어플리케이션 아키텍처를 좀 더 정확하게 반영할 수 있다.
* 각 특정한 API나 UI가 구현된 인바운드 어댑터가 비지니스 로직을 호출하고 
* 비지니스 로직은 다양한 외부 시스템을 호출하는 구조, 육각형 아키텍처는 MSA를 이루는 각 서비스 아키텍처를 기술하는 좋은 방법이다.

* 아키텍처 구성 요소를 정의하고, 그들 간 관계에 제약 조건을 두는 것은 같다.

https://medium.com/@vsavkin/hexagonal-architecture-for-rails-developers-8b1fee64a613

서비스 패턴같네



### 3. msa는 일종의 아키텍처 스타일이다.

* 모놀리식 아키텍처는 구현 뷰를 단일 컴포넌트로 구성한 아키텍처 스타일이다. - 다른뷰는 안등장함
* 모놀리식 어플리케이션은 육각형 아키텍처 방식으로 구성한 논리 뷰를 가질 수 있다.
* MSA는 구현 뷰를 다수의 컴포넌트로 구성하는 차이점이 있다.
* 컴포넌트는 곧 서비스이고 각 서비스는 자체 논리 뷰 아키텍처를 갖고있다.
* 전형적인 육각형 아키텍처임, 커넥터는 이런 서비스가 서로 협동할 수 있게 해주는 통신 프로토콜이다.



* ![image](https://user-images.githubusercontent.com/72075148/135720720-cae8d233-63a0-4db7-b57d-ebffe0049ec8.png)
* msa의 제약조건은 서비스를 느슨하게 결합한다는 것이다.
* 따라서 여러 서비스가 협동하는 방식에도 제약 사항이 있다.



#### 서비스란 무엇인가?

* 서비스는 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트
* 서비스는 클라이언트가 자신이 서비스하는 기능에 접근할 수 있도록 커맨드,쿼리,이벤트로 구성된 API를 제공한다.
* 서비스 작업은 크게 커맨드 CUD 와 쿼리 R 로 나뉜다.
* 서비스 API는 내부 구현 상세를 캡슐화 한다.
* 모놀리스와 달리 개발자는 API를 우회하여 서비스에 접근하는 코드를 작성할 수 없으므로 마이크로 서비스 아키텍처에서 모듈성이 보장된다.
* API를 통해서만 결합하므로 서비스가 직접 DB와 통신하는 일은 불가능하다.
* 클래스 필드와 같이 서비스의 영속적인 데이터는 반드시 프라이빗으로 유지한다.
* 이렇게 해야 개발자가 자신이 맡은 서비스의 DB스키마를 변경할 때 다른 서비스의 개발자와 조율하느라 시간을 허비하지 않는다.
* 서비스가 DB테이블을 공유하지 않기떄문에 런타임 격리도 향상된다.
* 어떤 서비스가 DB락을 획득하여 다른 서비스를 블로킹 하는 일 자체가 불가능하다.
* 물론 일관성 유지하는건 더 복잡해진다.



#### 공유 라이브러리의 역할

* 코드 중복을 방지하기 위해 여러 어플리케이션에서 재사용 가능한 기능을 라이브러리로 패키징하는 것은 개발자에게 당연한 일이다.
* msa에서도 공유 라이브러리를 사용하고픈 유혹에 빠지기 쉽다.
* 서비스 코드 중복을 줄이는건 좋지만 의도치 않은 서비스 간 결합도를 유발하지 않도록 조심 
* 변경 가능성이 조금이라도 있는 기능이면 별도으 ㅣ서비스로 구현하는게 나음
* 물론 바뀔일이 거의 없는 기능은 라이브러리에 담아 쓰는게 좋음

#### 서비스 규모는 별로 중요하지 않다.

* 크기보다는 작은 팀이 가장 짧은 시간에 다른 팀과 협동하는 부분은 최소로 하여 개발 가능한 서비스를 설계해야한다.
* 이론적으로는 한 팀이 한 서비스를 맡을 수도 있는데,.
* 대규모 팀을 꾸려야하거나 서비스를 테스트하는 시간이 너무 오래 걸리면 팀과 서비스를 분할해야한다.

* 다른 서비스의 변경분 때문에 내가 맡은 서비스도 계속 바꾸어야 한다거나,  내 서비스 때문에 다른 서비스가 바뀌어야 한다면 서비스가 느슨하게 결합되지 않았다는 반증
* 아니면 분산 모놀리스를 구축했기 때문





##### 마이크로서비스 아키텍처는 작고 느슨하게 결합된 서비스로 애플리케이션을 구상하기 때문에 유지보수성, 테스트성, 배포성등 개발 단계의 품질 속성이 개선된다. 또 조직 차원에서 소프트웨어를 더 빨리 개발할 수 있고 주된 목표는 아니지만 애플리케이션 확장성도 향상된다. 

##### MSA를  고민 중 이라면 먼저 현재 애플리케이션의 서비스를 어떻게 식별하고 서비스를 서로 협동시킬지 결정해야한다.

# 마이크로서비스 아키텍처 정의

* 도메인 전문가가 문서로 정리한 요건들과 기존 애플리케이션을 출발점으로 삼는다.
* 애플리케이션 아키텍처를 정의하는 3단계 프로세스를 설명하겠다!
* 누구나 기계적으로 따라할 수 있는게 아니라 실제로 여러차례 되풀이해야 할 수도 있고, 창의성이 필요한 부분도 있다.
* ![image](https://user-images.githubusercontent.com/72075148/135749648-6aad1b53-5402-4607-8c13-acf05ead5ed2.png)
* 애플리케이션은 사용자의 요청을 처리하기 위해 존재한다.
* 1단계는 애플리케이션 요건을 핵심 요청으로 추출하는 것 - rest / ipc기술이 아닌 좀 더 추상적인 관념으로
* 2단계는 어떻게 여러 서비스로 분해할지 결정하는 것이다. 여러 전략을 선택할 수 있다.
  * 비지니스 아키텍처 시각에서 비지니스 능력에 따라 서비스를 정의할 수도
  * DDD의 하위 도메인별로 서비스를 구성하는 전략도 가능함
  * 어떤 전략을 구사 하든 기술 개념이 아닌 비지니스 개념 중심으로 이루어진 서비스
* 3단계는 서비스별로 API를 정의하는 일이다.
  * 1단계에서 식별된 시스템 작업을 각 서비스에 배정한다.
  * 완전 혼자있는 애도있지만, 협동해야하는 서비스도 있다. 이 협동방식도 결정한다. - 보통 서비스에 추가 지원 작업을 두는 형태
    * API구현 시 사용할 IPC도 정한다.
* 분해 과정에는 장애물이 많다
  1. Network Latency - 서비스간 왕복이 너무 잦아 실제로 분해할 수 없는 경우도 있다.
  2. 서비스간 동기 통신으로 인해 가용성이 떨어지는 문제 - self contained service 개념으로 해결
  3. 데이터 일관성을 지키는 요건 - 사가로 해결한다
  4. 어클리케이션 도처에 숨어 있는 만능 클래스 - DDD개념을 활용하면 어렵지 않게 제거

## 1. 시스템 작업 식별

* 첫 단추임 , 사용자 스토리와 이와 연관된 사용자 시나리오등의 애플리케이션 요건임
* <Applying UML AND PARTEERNS> 의  객체 지향 설계 프로세스에서 영향을 받은 2단계 프로세스로 정의한다.
* 1단계는 시스템 작업을 기술하기 위해 필요한 보케블러리를 제공하는 핵심 클래스로 구성된 고수준의 도메인 모델을 생성
* 2단계는 시스템 작업 식별 후 그 동작을 도메인 모델 관점에서 기술하는 것

![image](https://user-images.githubusercontent.com/72075148/135750079-1a6ea4d6-1c61-4115-b394-7772b9e5255e.png)

* 도메인 모델은 사용자 스토리의 명사에서 도출한다 - event storming 사용 가능
* 시스템 작업은 동사에서 도출한다
* 각각 하나 이상의 도메인 객체와 그들의 관계로 기술한다.
* 시스템 작업은 도메인 모델을 CUD , + 모델간 관계를 맺고 끊음

### 고수준 도메인 모델 생성

* 도메인 모델을 대략 그려본다. 최종보단 단순하게
* 주문하기(Place Order) 스토리는 다양한 시나리오로 확장 가능
  * 전제 (Given)
    * 소비자가 있다.
    * 음식점이 있다.
    * 음식점은 소비자의 주소로 제시간에 음식을 배달할 수 있다.
    * 주문 총액이 음식점의 최소 주문량 조건에 부합한다.
  * 조건(When)
    * 소비자가 음식점에 음식을 주문한다.
  * 결과(Then)
    * 소비자 신용카드가 승인된다.
    * 주문이 PENDING_ACCEPTANCE 상태로 생성된다.
    * 생성된 주문이 소비자와 연관된다.
    * 생성된 주문이 음식점과 연관된다.
* 이 스토리에 포함된 명사는 Consumer, Order, Restaurant, CreditCard 등 다양함

* 마찬가지로 주문 접수 스토리는 (Accept Order)
  * 전제
    * 현재 주문은 PENDING_ACCEPTANCE 상태
    * 주문 배달 가능한 배달원이 있다.
  * 조건
    * 주문을 접수한 음식점은 언제까지 음식을 준비할 수 있다고 약속한다.
  * 결과
    * 주문 상태가 ACCEPTED로 변경된다.
    * 주문의 promiseByTime값을 음식점이 준비하기로 약속한 시간으로 업데이트한다.
    * 주문을 배달할 배달원을 배정한다.
* Courier(배달원) Delivery(배달) 클래ㅔ스가 필요할 듯 하다 - MenuItem , Address등 다른 클래스도 필요
* ![image](https://user-images.githubusercontent.com/72075148/135750769-4673c113-c871-4fde-86cc-7651263e8e1e.png)
  * 단면은 잘 나타내지만 시나리오가 없으면 그냥 이쁜 그림임
  * 시나리오에 맞게 시스템 작업을 정의할 차례이다.

### 시스템 작업 정의

* 어떤 요청을 처리할지 식별하는 단계이다. UI는 자세히 안다룸

* 커멘드 - CUD / 쿼리 - R 로 나눠짐

* rest / rpc, 메시징 endpoint로 구현 되겠지만 일단 추상적으로 생각 - 커맨드를 식별하자.

* 사용자 스토리/시나리오에 포함된 동사를 먼저 분석해보자.

  * | 액터   | 스토리                                        | 커맨드                                                       | 설명                                                         |
    | ------ | --------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 소비자 | 주문 생성                                     | createOrder()                                                | 주문을 생성한다.                                             |
    | 음식점 | 주문 접수<br />주문 픽업 준비됨               | acceptOrder()<br />noteOrderReadyForPickUp()                 | 주문이 접수됨 주어진 시각까지 음식을 준비 지시<br />주문한 음식이 픽업 가능함을 알린다. |
    | 배달원 | 위치 업데이트<br />배달 픽업<br />주문 배달됨 | noteUpdatedLocation()<br />nodeDeliveryPickedUp()<br />noteDeliveryDelivered() | 배달원의 현재 위치를 업데이트 한다.<br />주문한 음식을 배달원이 픽업했음을 알린다<br />주문한 음식을 배달원이 소비자에게 배달했음을 알린다. |

  

* 커맨드는 매개변수, 반환값, 동작 방식의 명세를 도메인 모델 클레스로 정의한다.

* 이 명세는 작업 호출 시 충족되어야 할 선행조건, 작업 호출 후 충족되어야 할 후행 조건으로 구성된다.

* createOrder() 시스템 작업의 명세는 다음처럼 구성됨

  * | 작업      | createOrder(소비자 ID, 결제 수단, 배달 주소, 배달 시각, 음식점 ID, 주문 품목) |
    | --------- | ------------------------------------------------------------ |
    | 반환값    | orderId                                                      |
    | 선행 조건 | 소비자가 존재하고 주문을 할 수 있다.<br />주문 품목은 음식점의 메뉴 항목에 들어있다.<br />배달 주소 / 시각은 음식점에서 서비스 할 수 있다. |
    | 후행 조건 | 소비자 신용카드는 주문 금액만큼 승인 처리되었다<br />주문은 PENDING_ACCEPTANCE 상태로 생성되었다. |

    선행 조건은 주문하기 시나리오의 전제를, 후행 조건은 결과를 나타낸다.

  * 시스템 작업 호출시 선행 조건 확인 후 후행을 만족시키는 액션을 수행한다.

* acceptOrder() 시스템 작업 명세

  * | 작업      | acceptOrder(restaurantId, orderId, readyByTime)              |
    | --------- | ------------------------------------------------------------ |
    | 반환값    | -                                                            |
    | 선행 조건 | order.status 는 PENDING_ACCEPTANCE이다.<br />배달원은 주문을 배달할 수 있다. |
    | 후행 조건 | order.status는 ACCEPTED로 변경되었다.                        |

* 데이터를 가져오는 쿼리도 중요하지만 아키텍처와 연관된 시스템 작업은 대부분 커멘드
* FTGO 어플리케이션은 커맨드 외에도 사용자가 의사 결정을 하는 데 필요한 정보를 UI에 제공하는 쿼리를 제공해야한다.
  1. 사용자는 배달 주소 및 시간을 입력합니다.
  2. 시스템은 배달 가능한 음식점을 표시합니다.
  3. 사용자는 음식점을 고릅니다.
  4. 시스템은 메뉴를 표시합니다.
  5. 사용자는 원하는 메뉴를 선택한 후 체크아웃 합니다.
  6. 시스템은 주문을 생성합니다.

* findAvaliableRestaurants(deliveryAddress, deliveryTime): 주어진 장소/시간으로 배달 가능한 음식점 목록 조회
* findRestaurantMenu(id): 메뉴 항목 등 음식점 정보를 조회한다.

* 지리검색이 필요한 findAvaliableRestaurants는 더 복잡한 쿼리라서 아키텍처 관점에서 중요
  * 지리 검색 컴포넌트는 배달 주소에 해당하는 곳 주변의 전체 음식점을 검색한 후, 
  * 주문을 준비/픽업할 시점에 영업 종료를 하는 음식점을 필터해아한다.
  * 소비자가 볼때마다 실행되니까 성능 중요



* 고수준 도메인 모델과 시스템 작업을 보면 애플리케이션이 무슨 일을 하는지 알 수 있기 땜누에 아키텍처를 정의하는 데 유용



### 서비스 정의 - 비즈니스 능력 패턴별 분해

* 첫 번째 전략은 비즈니스 능력에 따라 분해하는 것

* 비즈니스 아키텍처 모델링에서 비롯된 비즈니스 능력은 비즈니스가 가치를 생산하기 위해 하는 일을 말한다.

* 업종마다 다름

* 보험 회사라면 증권 인수, 클레임관리, 과금, 컴플라이언스

* 온라인 쇼핑몰은 주문관리, 재고관리, 선적 등

* ##### 비즈니스 능력별로 분해해라.

* 능력에 따라 서비스를 정의한다.

#### 비즈니스 능력은 곧 조직이 하는 일

* 비즈니스를 하는 방법이야 급격하게 달라질 수 있지만, 능력은 크게 달라지지 않는다.
* 은행가서 수표 예금 / ATM 예금 / 폰밴킹 예금

#### 비즈니스 능력 식별 

* 조직의 목표, 구조, 비즈니스 프로세스를 분석하여 식별한다.
* 기술보다 비즈니스 위주라는 점만 제외하면 일종의 서비스임
* 비즈니스 능력 명세는 입/출력 SLA등 다양한 컴포넌트로 구성된다.
  * 보험사 증권 인수 능력은 입력 - 소비자 신청서 / 출력 - 승인,단가
* 여러 개의 하위 능력으로 분해 가능
* 클레임이라는 비즈니스 객체는 - 클레임 관리 능력을 중심으로, 클레임 정보 관리, 검토, 지불 관리 등의 하위 능력
* FTGO의 비즈니스 서비스 능력
  * 공급자 관리
    * 배달원 관리 - 배달 정보 관리
    * 음식점 정보 관리 - 메뉴, 위치, 영업 시간, 기타 정보 관리
  * 소비자 관리 - 소비자에 관한 정보 관리
  * 주문 접수 및 이행
    * 주문 관리 - 소비자가 주문을 생성/관리할 수 있게 한다.
    * 음식점 주문 관리 - 음식점의 주문 준비 상태를 관리
    * 로지스틱
    * 배달원 가용성 관리 - 배달원이 배달 가능한지 실시간 관리
    * 배달 관리 - 주문을 소비자에게 배달
  * 회계
    * 소비자 회계 - 소비자 과금 관리
    * 음식점 회계 - 음식점 지불 관리
    * 배달원 회계 - 배달원 지불 관리

*  최상위는 공급자 관리, 소비자 관리, 주문 접수 및 이행, 회계, - etc, 마케팅 등 ..

### 비즈니스 능력을 여러 서비스로

* 최상위에 바로 매핑된 경우도 있지만 하위 능력에 매핑 된 경우도
* 능력 체계의 어느 수준을 서비스에 매핑할지는 주관적으로 판단 할 문제지만
  * 공급자 관리 능력의 두 하위능력은 각각 두 서비스로 매핑 - 
    * 음식점과 배달원은 서로 완전 다른 공급자
  * 주문 접수 및 이행 능력은 서비스마다 상이한 프로세스 단계를 담당하도록 세 서비스로 매핑
  * 배달원 가용성 관리와 배달 관리 능력은 밀접한 연관 - 한서비스
  * 회계 능력은 유형별 회계가 대동소이 하므로 자체 서비스에 매핑
  * ![image](https://user-images.githubusercontent.com/72075148/135752074-c8721002-59ed-455e-81d1-6d4faf778405.png)

* 결제 및 과금 서비스도 분리하는게 나음

* 거의 변하지 않는 비즈니스 능력에 따라 구성하면 비교적 안정적인 아키텍처를 구축할 수 있다.
* 나중에 비즈니스 요건이 달라져도 아키텍처를 구성하는 개별 컴포넌트는 아키텍처는 그대로 둔 채 발전 시킬 수 있다.
* 사진은 첫 버전일 뿐임
* 각각의 핵심 아키텍처 서비스와 나머지 서비스가 어떻게 협동하는지 살피는 과정이 중요하다.
* IPC가 너무 잦아 분해하는 것이 외려 비 효율적이라서 서비스를 재결합 하는 경우도 있다.
* 나누는게 나을정도로 복잡해지는 경우가 있다.

### 서비스 정의 - 하위 도메인 패턴별 분해

* ddd는  <Domain Driven Design - Eric Evans> 명저에도 나오지만 객체 지향 도메인 모델 중심의 복잡한 소프트웨어 앱 구축법임
* 도메인 내부에서 문제 해결이 가능한 형태로 도메인을 모델링 하는 기법
* DDD는 팀에서 사용할 보케블러리 즉 공용 언어를 정의한다.
* 도메인 모델은 어플리케이션 설계/구현에 밀접하게 반영된다.
* DDD - 하위도메인과 경계 컨텍스트 개념

##### 하위 도메인에 따라 분해

##### DDD 하위 도메인별로 서비스를 정의한다.

* 기존에는 전체 비즈니스를 포괄하는 단일 통합 모델을 만들었지
  * 하나의 모델에 여러 부서 합의 이끌어내기 힘들지
  * 쓰는 단어가 다를수도 있고
* 각 하위 도메인 마다 도메인 모델을 따로 정의한다.
* 비즈니스 능력과 하위 도메인은 유사하지?
* 도메인 모델의 범위를 DDD 용어로는 경계 컨텍스트라고 한다.
  * 코드 아티팩트를 포함하고, MSA에 DDD를 적용하면 각 서비스가 경계 컨텍스트가 된다.

![image](https://user-images.githubusercontent.com/72075148/135752662-919bf8b4-85d5-4ae8-8baa-820f31986c54.png)

* DDD와 MSA는 찰떡 궁합
* DDD의 하위 도메인, 경계 컨텍스트는 MSA의 서비스와 잘 맞고 팀 개념도 잘 맞음



### 분해 지침

SRP와 CCP- 공동 폐쇄 원칙

### SRP

클래스는 오직 하나의 변경 사유를 가져야한다.

* 클래스가 맡은 책임은 각각 그 클래스가 변경될 잠재적 사유이다.
* 클래스가 독립적으로 변경 가능한 책임을 여럿 짊어지고 있으면 안정적이지 않다.
* 이 원칙을 MSA에 적용하면 하나의 책임만 가진 작고 응집된 서비스를 정의할 수 있다.
* 주문 접수, 준비, 배달에 이르기까지 소비자가 주문한 음식이 배달되는 과정 하나하나 모두 개별 서비스가 맡아 처리한다.

### CCP 공동 폐쇄 원칙

패키지의 클래스들은 동일한 유형의 변경에 대해 닫혀있어야한다. 패키지에 영향을 주는 변경은 그 패키지에 속한 모든 클래스에 영향을 끼친다.

* 어떤 클래스가 동일한 사유로 밎물려 변경되면 동일한 패키지에 있어야 한다는 것
* 비즈니스 규칙도 상이한 측면을 구현한 클래스가 여럿 있을 수 있다.
* 규칙이 바뀌어도 가급적소수(1개 이상적)의 패키지에 있는 코드만 고치면 될 수 있게 만들자는 것
* CCP를 잘 지키면 앱의 유지보수성이 현저히 향상
* 동일 사유로 변경되는 컴포넌트를 같은 서비스에 묶으면 요건이 바뀌어도 수정/배포 서비스는 하나 - 소수

## 서비스 분해의 장애물

### 네트워크 지연

* 분산 시스템의 고질적인 문제
* 서비스를 여러개 나누면 서비스 간 왕복 횟수가 급증한다.
* 한 차례 왕복으로 여러 객체를 한 번에 가져오는 배치 API를 구현하거나
* 값비싼 IPC를 언어 수준의 메서드나 함수 호출로 대체하는 식으로 서비스 결합에 따른 지연 시간을 줄인다

### 동기 IPC로 인한 가용성 저하

* createOrder()는 타 서비스의 REST API를 동기 호출하는 게 제일 쉬운 구현
* 타 서비스 중 하나만 불능이여도 주문은 생성되지 않으므로 REST 프로토콜은 가용성이 떨어진다.
* 감수 해야하는 트레이드 오프라고 볼 수 있지만 비동기 메시징으로 강한 결합도를 제거하고 가용성을 높이는 방법이 더 좋다.
* 그거 생각나는데,... 흠 추천 시스템?

### 여러 서비스에 걸처 데이터 일관성 유지

* 여러 서비스에 걸처 데이터 일관성을 유지하는 일도 난제,,,
* 음식점이 주문 접수하려면 주방 서비스는 티켓 상태를 변경
* 배달 서비스는 배달 스케쥴을 잡아야함
* 두 서비스 모두 업데이트치고, 아토믹하게 일어나야함
* 과거에는 커밋 방식의 2단계 분산 트랜잭션을 많이 썻지만 요즘에는 사가라는 전혀 다른 방식으로 트랜잭션을 관리한다.
* 사가는 메시징을 이용한 일련의 로컬 트랜잭션이다.
* 기존 ACID 트랜잭션 보다는 복잡하지만, 다양한 상황에서도 잘 동작한다.
* 한 가지 단점은 최종 일관성을 보장한다는 것
* 어떤 데이터를 원자적으로 업데이트, 해야하면 그 데이터를 서비스 내부에 두어야하는데 결국 분해의 걸림돌

### 일관된 데이터 뷰 확보

* 여러 디비에 걸쳐 일관된 데이터 뷰를 확보하기는 어려움
* db가 일관적이더라도 전역 범위에서 일관된 데이터 뷰는 확보할 수 없다.
* 어떤 데이터를 일관된 뷰로 바라보려면 하나의 서비스를 내부에 두어야하는데 걸림돌임
* 다행히 실제로 문제 안됨

### 만능 클래스는 분해의 걸림돌

* 앱 곳곳의 만능 클래스는 걸림돌임
* 앱의 여러 측면에 관한 비지니스 로직이 있는데, 굉장히 많은 필드가 다수의 컬럼을 가진 DB테이블에 매핑된 경우가 많다.
* 이런 클래스는 모든 앱에 하나쯤은 있지?
* 만능 클래스는 앱의 여러 측면의 상태/동작을 보이지 않게 감싸므로 이 클래스를 사용하는 전체 비지니스 로직을 서비스로 분리하려면 골치아픔
* Order가 만능 클래스임
* ![image](https://user-images.githubusercontent.com/72075148/135753327-2ebd8974-ae0c-4706-90fa-8c08424d51b5.png)
* Order를 라이브러리로 묶고 Order db를 중앙화 한다? 노노 ..위배
* 주문 DB를 주문 서비스 안으로 캡슐화 해서 다른 서비스가 주문 서비스를 통해서만 조회/수정하게.
* 하지만 주문 서비스는 비지니스 로직이 거의 없는 빈껍데기 도메인 모델을 가진 데이터 서비스로 전락
* DDD라는 멋진 해결책!
* 각 서비스를 자체 도메인 모델을 갖고있는 개별 하위 도메인으로 취급한다.
* 모두 각자 버전의 Order 클래스를 가진 도메인 모델을 따로 두는거!
* 가장 좋은 사례가 배달 서비스임
* ![image](https://user-images.githubusercontent.com/72075148/135753470-0f788278-9f99-45ee-88e6-f30ff052cd47.png)
* 배달 서비스는 다른 주문 속성에 관심이 없다.
* ![image](https://user-images.githubusercontent.com/72075148/135753481-672becd8-1fdc-4f34-86cd-1be7892645c7.png)
* ![image](https://user-images.githubusercontent.com/72075148/135753509-0ccf2dab-bde2-44a2-8c1a-4da7f33fca62.png)
* 뷰가 가장 복잡하지만 ~ 원ㄹ ㅐ버전에 비하면 단순하다!
* 일관성 유지는 앱의 몫 
* 신용카드 승인 후 주방의 Ticket을 트리거
* 주문 거부 시 반드시 주문 취소 후 신용카드 승인 내역 취소
* 일관성은 이벤트 주도 메커니즘인 사가를 활용

## 서비스 API 정의

* 외부 클라이언트 또는 타 서비스가 호출하는 시스템 작업
* 서비스 간 협동을 지원하기 위해 타 서비스 호출 전용으로 만든 작업

* 서비스 이벤트는 주로 타 서비스와 협동하기 위해 발행한다.
* 4장 - 이벤트 활용해서 사가를 구현하고 일관성을 유지하는 방법은 
* 7장 - 이벤트를 이용해서 CQRS 뷰를 업데이트하고 쿼리를 효과적으로 지원하는 기법
* 이벤트는 앱에서 외부 클라이언트에 알림을 보내는 용도로 쓰임

* 서비스 API를 정의하려면 각각 시스템 작업을 서스로 매핑, 어느 서비스가 서로 협동할 지 파악
* 협동 필요하면 어느 서비스가 어느 API를 타 서비스에 제공해야하나 정함

### 시스템 작업을 서비스로 배정

* 어느 서비스가 요청의 진입점인지 결정한다.

* noteUpdatedLocation()은 배달원 위치 업데이트니까 배달원 서비스에 배정 되어있어야할듯 한데, ? 배달 서비스가 위치 필요한거니까 ...

* | 서비스        | 작업                                                         |
  | ------------- | ------------------------------------------------------------ |
  | 소비자 서비스 | createConsumer()                                             |
  | 주문          | createOrder()                                                |
  | 음식점        | findAvailableRestaurants()                                   |
  | 주방          | acceptOrder()<br />nodeOrderReadyForPickUp()                 |
  | 배달          | noteUpdatedLocation()<br />noteDeliveryPickUp()<br />noteDeliveryDelivered() |

### 서비스 간 협동 지원에 필요한 API 확정

* 하나로 처리 가능한 - createConsumer() , 도 있고 여러 서비스 걸친거도 있음
* createOrder()
  * 소비자 서비스 - 소비자가 주문 가능한지 확인하고 지불 정보 획득
  * 음식점 서비스 - 주문 품목이 올바른지 소비자가 요청한 배달 주소/시간에 맞추어 해당 음식점이 준비 가능하지 최소 주문량이상 인지 확인 후 주문 품목별 단가 정보 조회ㅏ
  * 주방 서비스 - 티켓 생성
  * 회계 서비스 - 소비자 신용카드 승인
* acceptOrder()은 주방 서비스가 배달 서비스 호출해서 배달원 스케줄 조정하는 작업이 필요

| 서비스      | 작업                                                         | 협동자                                                       |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 소비자      | verifiyConsumerDetails()                                     | -                                                            |
| 주문        | createOrder()                                                | 소비자 서비스 - verifyConsumerDetails()<br />음식 - verifyOrderDetails()<br />주방 - createTicket() |
| 음식점      | findAvailableRestaurants()<br />verifyOrderDetails()         |                                                              |
| 주방        | createTicket()<br />acceptOrder()<br />noteOrderReadyForPickUp() | 배달 - scheduleDelivery()                                    |
| 배달        | scheduleDelivery()<br />noteUpdateLocation()<br />noteDeliveryPickedUp()<br />noteDeliveryDelivered() | -                                                            |
| 회계 서비스 | authorizeCard()                                              |                                                              |

* 서비스를 식별하고 각 서비스가 어떤 작업을 구현해야하나 식별 했지?
* 추상적인 스케치에 불과하다.

* 어떤 IPC를 사용하는지, 동기적 요청 기반이 떠올르지만 비동기 메시징이 중추적인 역할

# 마치며

* 아키텍처는 애플리케이션 개발 속도에 직접 영향을 주는 갖가지 ~성 을 좌우한다 - 관리성 테스트성 배포성
* MSA는 애플리케이션의 관리성, 테스트성, 배포성을 높인다.
* 기술적 관심사 보다 비즈니스 능력, 하위 도메인 등 비즈니스 관심사 위주로 구성이 된다.
* 서비스를 분해하는 패턴은
  * 비즈니스 능력에 따른 분해 - 비즈니스 아키텍처 기반
  * 하위 도메인에 따른 분해 - DDD 개념 기반
* DDD를 적용하고 서비스마다 도메인 모델을 따로 설계하면 의존 관계가 뒤엉켜 분해를 가로막는 만능 클래스를 제거 가능










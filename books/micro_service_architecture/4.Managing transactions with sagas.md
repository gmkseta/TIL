# Managing Transaction with Sagas

* 단일 서비스 내부의 트랜잭션은 ACID가 보장하지만 여러 서비스의 데이터를 업데이트하는 트랜잭션은 구현이 까다롭다.
* 사가라는 메시지 주도 방식의 로컬 트랜잭션을 사용한다.
* ACID에서 ( Atomicity, Consistency, Isolation, Durability ) 에서 I가 빠짐 , 격리가 되지않는다. 
* 동시 비정상의 영향을 방지하거나 줄일 수 있는 설계기법을 적용해야함

## 1. MSA에서의 트랜잭션 관리

### 1.1 분산 트랜잭션의 필요성

* createOrder는 주문 가능한 소비자인지 확인, 내역 확인, 소비자 신용카드 승인, DB에 주문 생성 -> @Transactional로 처리
* 데이터가 여러 서비스에 흩어져 있는 마이크로서비스 아키텍처는 복잡하다.
* createOrder는 소비자 서비스, 주문 서비스, 주방 서비스, 회계 서비스 등 여러 서비스의 데이터에 접근
* 서비스마다 DB가 따로 있기 때문에 여러 DB에 걸쳐 데이터 일관성을 유지할 수 있는 수단을 강구해야한다.

### 1.2 분산 트랜잭션의 문제점

* X/Open DTP 모델은  분산 트랜잭션 관리의 사실상 표준이다.

* XA는 2단계 커밋을 이용하여 전체 트랜잭션 참여자가 반드시 커밋 아니면 롤백을 하도록 보장한다.

* XA호환 DB / 메시지 브로커 / DB 드라이버 / 메시징 API / XA 전역 트랜잭션 ID 전파 프로세스 간 메커니즘 으로 구성

  ![image](https://user-images.githubusercontent.com/72075148/138583450-e37c59ad-e2a0-4f91-9950-6117d506324f.png)

* NoSQL DB, 현대 메시지 브로커 (RabbitMQ, 아파치 카프카)는 분산 트랜잭션을 지원하지 않음
* 동기 IPC 형태라서 가용성이 떨어짐
  * 참여한 서비스가 모두 가동 중 이어야 커밋이 가능함
* CAP 정리 - Consistency, Availability, Partition tolerance 중 두가지만 가능함 - 요즘은 일관성보다 가용성

### 1.3 데이터 일관성 유지 - 사가패턴

* msa에서 분산 트랜잭션 없이 데이터 일관성을 유지하는 메커니즘
* 여러 서비스를 업데이트하는 시스템 커맨드마다 사가를 하나씩 정의한다.
* 로컬 트랜잭션임, - 각 로컬 트랜잭션은 ACID 트랜잭션 프레임워크/라이브러리로 서비스 별 데이터를 업데이트

![image](https://user-images.githubusercontent.com/72075148/138583618-3fa73e4c-8f94-4b02-a6ec-9f3e20e86369.png)

* 첫 번째 로컬 트랜잭션은 외부 요청에 의해 시작됨
* 나머지 5개는 선행 트랜잭션이 완료되면 트리거 된다.

1. 주문 서비스 - 주문을 APPROVAL_PENDING으로 생성
2. 소비자 서비스 - 주문 가능한 소비자인지 확인한다.
3. 주방 서비스 - 주문 내역을확인하고 티켓을 CREATE_PENDING 상태로 생성
4. 회계 서비스 - 소비자 신용카드를 승인
5. 주방 서비스 - 티켓 상태를 AWAITING_ACCEPTANCE 로 변경
6. 주문 서비스 - 주무 상태를 APPROVED로 변경

* 서비스는 로컬 트랜잭션이 완료되면 메시지를 발행해서 다음 사가 단계를 트리거 한다.
* 느슨하게 결합하고, 사가가 반드시 완료되도록 보장한다.
* 메시지 수신자가 일시 불능 상태면 메시지 브로커는 버퍼링

#### 사가는 보상 트랜잭션으로 변경분을 롤백

* 사가는 단계마다 로컬 DB에 변경분을 커밋하므로 자동 롤백은 불가능하다.
* 가령 주문 생성 사가 4번째 단계에서 신용카드 승인이 실패하면 1~3번째 단계에서 적용된 변경분을 명시적으로 undo
* N+1 번째 사가 트랜잭션이 실패하면 이전 N개의 트랜잭션을 undo,
* 커밋의 역순으로 하면 됨
* 읽기 전용 단계나 항상 성공하는 단계 다음에 이어지는 단게는 보상 트랜잭션이 필요없다.
* ![image](https://user-images.githubusercontent.com/72075148/138583797-a4e1a656-9046-45bb-b2da-5592a2008479.png)

## 2. Coordinating Sagas 사가 편성 

* 사가는 단계를 편성하는 로직으로 구성된다.
* 시스템 커맨드가 사가를 시작할 때 이 편성 로직은 첫 번째 사가 참여자를 정하여 로컬 트랜잭션 실행을 지시
* 트랜잭션이 완료되면 그다음 사가 참여자를 호출하는 과정이 모든 단계가 실행 될때까지 반복
* 도중 하나라도 실패하면 사가는 보상 트랜잭션을 역순으로 실행한다.
* 두 가지의 사가 편성 로직
  * 코레오그래피(choreography) - 의사 결정과 순서화를 사가 참여자에게 맡긴다. 사가 참여자는 주로 이벤트 교환 방식으로 통신
  * 오케스트레이션(orcchestration) - 사가 편성 로직을 사가 오케스트레이터에 중앙화한다. 사가 오케스트레이터는 사가 참여자에게 커맨드 메시지를 보내 수행할 작업을 지시

### 2.1 코레오그래피 사가

* 중앙 편성자가 없고 사가 참여자가 서로 이벤트를 구독해서 그에따라 반응

#### 주문 생성 사가 구현 - 코레오그래피 스타일

* 주문 서비스를 시작으로 각 참여자는 자신의 DB를 업데이트하고 다음 참여자를 트리거하는 이벤트를 발행한다.
* ![image](https://user-images.githubusercontent.com/72075148/138586037-aea352e7-2ce2-4a7f-b606-6c53106762f8.png)

1. 주문 서비스 - 주문을 APPROVAL_PENDING으로 생성 - 주문 생성 이벤트를 발행
2. 소비자 서비스 - 주문 생성 이벤트를 수신 - 소비자가 주문을 할 수 있는지 확인 - 소비자 확인 이벤트를 발행
3. 주방 서비스 - 주문 생성 이벤트를 수신 - 주문 내역 확인 - 티켓을 CREATE_PEDNING상태로 생성 - 티켓 생성됨 이벤트를 발행
4. 회계 서비스 - 주문 생성 이벤트를 수신 - 신용카드 승인을 PEDNING 상태로 생성
5. 회계 서비스 - 티켓 생성 및 소비자 확인 이벤트 수신 - 소비자 신용카드 과금 - 신용카드  승인됨 이벤트를 발행
6. 주방 서비스 - 신용카드 승인 이벤트 수신 - 티켓 상태를 AWAITING_ACCEPTANCE로 변경
7. 주문 서비스 - 신용카드 승인 됨 이벤트 수신 - 주문 상태를 APPROVED로 변경 - 주문 승인됨 이벤트를 발행

![image](https://user-images.githubusercontent.com/72075148/138586123-7a0ed5b8-b4bc-4337-9c0a-85d60270ba2e.png)

5. 신용카드 승인 실패 이벤트 발행
6. 주방서비스 - 신용카드 승인 실패 이벤트 수신 - 티켓 상태를 REJECTED로 변경
7. 주문 서비스 - 신용카드 승인 실패 이벤트 수신 - 주문 상태를 REJECTED로 변경

#### 확실한 이벤트 기반 통신

1. DB 업데이트와 이벤트 발행은 원자적으로 일어나야한다.
   * 사가 참여자가 서로 확실하게 통신하려면 트랜잭셔널 메시징 (3)
2. 사가 참여자는 자신이 수신한 이벤트와 자신이 가진 데이터를 연관 지을 수 있어야한다. -  상관관계 ID가 포함된 이벤트 발행

#### 장점

* 단순함 - 비지니스 객체를 생성, 수정, 삭제할 때 서비스가 이벤트를 발행
* 느슨한 결합 - 구독할 뿐 서로 직접 알지 못한다.

#### 단점

* 이해하기 어렵다 - 오케스트레이션 사가와 달리 정의, 구현 로직이 흩어져있다. 어떻게 동작하는지 이해하기 어려운 편
* 서비스간 순환 의존성 - 서로 이벤트를 구독하는 특성상, 순환 의존성이 발생하기 쉽다.
  * 주문서비스 - 회계서비스 - 주문 서비스 / 반드시 문제는 아니지만 잠재적인 설계 취약점
* 단단히 결합될 위험성 - 자신에게 영향을 미치는 이벤트를 모두 구독해야함
  * 회계 서비스는 소비자 신용 과금/환불 모든 이벤트 구독 , ...

간단하면 코레오그래피가 좋지만 복잡하면 오케스트레이션이나옴

### 2.2 오케스트레이션 사가

* 오케스트레이터 클래스를 정의 - 커맨드/비동기 응답 상호 작용을 하여 참여자와 통신
* 사가 단계 실행하기위해 참여자가 무슨일을 해야 하는지 컨맨드 메시지에 적어 보냄
* 사가 참여자가 작업을 마치고 응답 메시지를 오케스트레이터에 주면 오케스트렝터는 응답 메시지를 처리한 후 다음 사가 단계를 어느 참여자가 수행할지 결정

#### 오케스트레이션 스타일

![image](https://user-images.githubusercontent.com/72075148/138586503-86db2662-bd54-4e5a-9893-14c1b6c82755.png)

* 주문 서비스는 먼저 주문 및 주문 생성 사카 오케스트레이터를 상성

1. 사가 오케스트레이터가 소비자 확인 커맨드를 소비자 서비스에 전송
2. 소비자 서비스는 소비자 확인 메시지를 응답
3. 사가 오케스트레이터는 티켓 생성 커맨드를 주방 서비스에 전송
4. 주방 서비스는 티켓 생성 메시지를 응답
5. 사가 오케스트레이터는 신용카드 승인 메시지를 회계서비스에 전송
6. 회계 서비스는 신용카드 승인됨 메시지를 응답
7. 사가 오케스트레이터는 티켓 승인 커맨드를 주방 서비스에 전송
8. 사가 오케스트레이터는 주문 승인 커맨드를 주방 서비스에 전송

주문 서비스도 마치 다른 참여자인 것처럼 취급

adr - 아키텍처 디자인 리뷰?

#### 사가 오케스트레이터를 상태 기계로 모델링

* 상태 기계는 상태와 이벤트에 의해 트리거되는 상태 전이로 구성
* 전이가 발생할 때마다 액션이 일어나는데, 사가의 액션은 사가 참여자를 호출하는 작용
* 상태 간 전이는 사가 참여자가 로컬 트랜잭션을 완료하는 시점에 트리거
* 로컬 트랜잭션의 상태와 결과에 따라 상태 전이를 어떻게 하고 어떤 액션을 취할지 결정
* 효율적으로 테스트 가능하고 실제 설계, 구현, 테스트가 쉽다.

![image](https://user-images.githubusercontent.com/72075148/138586895-4ba48ac4-ab04-4bff-8f7f-e30a37ad6c31.png)

* 소비자 확인 - 초기상태 사가는 소비자 서비스가 주문 가능한 소비자인지 확인할 때까지 기다린다.

* 티켓 생성 - 사가는 티켓 생성 커맨드에 대한 응답을 기다린다.

* 신용카드 승인 - 회계 서비스가 소비자 신용카드를 승인할 때까지 기다린다.

* 주문 승인됨 - 사가가 성공적으로 완료되었음을 나타내는 최종 상태

* 주문 거부됨 - 참여자 중 하나가 주문을 거부했음을 나타내는 최종 상태

#### 사가 오케스트레이션과 트랜잭셔널 메시징

* 오케스트레이션 사가는 DB를 업데이트하는 서비스와 메시지를 발행하는 서비스가 단계마다 있다.
* 주문 서비스는 주문 및 주문 생성 사가 오케스트레이터를 생성 후 1번 사가 참여자에게 메시지를 보낸다.
* 사가 참여자는 DB를 업데이트한 후 응답 메시지를 보내는 식으로 커맨드 메시지를 처리한다.
* 다시 주문 서비스는 사가 오케스트레이터 상태를 업데이트한 후 커맨드 메시지를 다음 사가 참여자에게 보낸다.
* 이런식으로 참여자의 응답 서비스를 처리, 이때 트랜잭셔널 메시지를 사용해서 DB업데이트와 메시지 발행 아토믹

#### 장점 

* 의존 관계 단순화 - 순환 의존성이 없음
* 낮은 결합도 - 각 서비스는 오케스트레이터가 호출하는 API를 구현할 뿐 사가 참여자가 발행하는 이벤트는 몰라도됨
* 관심사를 더 분리하고 비지니스 로직을 단순화 - 사가 편성 로직이 사가 오케스트레이터 한곳에만 있으므로 도메인 객체는 더 단순해지고 자신이 참여한 사가에대해서는 잘 알지 못함

#### 단점 

* 비즈니스 로직을 오케스트레이터에 너무 많이 중앙화 하면 똑똑한 오케스트레이터 하나가 깡통 서비스에 일일히 할 일을 지시하는 모양새
* 순서만 담당하고 비즈니스로직은 안갖게 ...

## 3. 비격리 문제 처리

* ACID의 격리성은 동시에 실행 중인 여러 트랜잭션의 결과가 어떤 순서든 실행된 결과와 동일함을 보장
* 사가는 격리성이 빠져있다. 사가의 한 트랜잭션이 커밋한 변경분을 다른 사가가 즉시 바라볼 수 있음
* 두 가지 문제
  1. 한 사가가 실행 중에 접근하는 데이터를 도중에 다른 사가가 바꿔치기할 수 있다.
  2. 한 사가가 업데이트를 하기 이전 데이터를 다른 사가가 읽을 수 있어서 데이터 일관성이 떨어질 수 있다.
* 사가는 ACD 트랜잭션
  * 원자성 ( Atomicity ) : 사가는 트랜잭션을 모두 완료하거나 모든 변경분을 언두해야함
  * 일관성 ( Consistency ) : 서비스 내부의 참조 무결성은 로컬 DB가 , 여러 서비스에 걸친 참조 무결성은 서비스가 처리함
  * 지속성 ( Durability ) : 로컬 디비가
* 격리가 안되면 비정상이 나타날 가능성이 있음, 트랜잭션이 차례대로 실행되지 않는 것 처럼 데이터를 읽고 쓰게 됨
* 사가를 동시 실행한 결과와 순차 실행한 결과가 달라질 수 있음
* 실제로 성능 향상을 위해 격리 수준을 낮추어 개발하는 경우는 흔하고, rdbms는 격리 수준을 트랜잭션마다 다르게 하며, 약한 격리 수준을 씀 - 실무에선

### 3.1 비정상 개요

* 소실된 업데이트 - 한 사가의 변경분을 다른 사가가 미처 못 읽고 덮어 씁니다.
* 더티 읽기 - 사가 업데이트를 하지 않은 변경분을 다른 트랜잭션이나 사가가 읽습니다.
* 퍼지/반복 불가능한 읽기 - 한 사가의 상이한 두 단계가 같은 데이터를 읽어도 결과가 달라지는 현상, 다른 사가가 그 사이 업데이트를 했기 때문에 생기는 문제

##### 소실된 업데이트

1. 주문 생성 사가 첫 번째 단계에서 주문을 생성
2. 사가 실행 중 주문 취소 사가가 주문을 취소
3. 주문 생성 사가 마지막 단계에서 주문을 승인

주문 생성 사가는 주문 취소 사가가 업데이트한 데이터를 덮어 씌우고 결국 고객은 취소한 주문의 음식을 배달 받음

##### 더티 읽기

* 업데이트 중인 데이터를 다른 사가가 읽을 때 발생
* 소비자 서비스 - 신용 잔고를 늘린다.
* 주문 서비스 - 주문을 취소 상태로 변경
* 배달 서비스 - 배달 취소

주문 취소 사가와 주문 생성 사가의 실행이 서로 겹쳐 실 중인데, 배달을 취소하기에는 너무 늦어서 주문 취소 사가가 롤백되는 경우

1. 주문 취소 사가 - 신용 잔고를 늘린다.
2. 주문 생성 사가 - 신용 잔고를 줄인다
3. 주문 취소 사가 - 신용 잔고를 줄이는 보상 트랜잭션이 가동

주문 생성 사가는 잔고를 더티 읽기 하게되고, 소비자는 한도를 초과하는 주문도 할 수 있게 될 것이다.

취소가 먼저오면 늘리느라 잔고보다 더 많은 주문이 가능

### 3.2 비격리 대책

* 비격리로 인한 비정상을 방지하고 비즈니스에 미치는 영향을 최소화하는 방향으로 사가를 작성할 의무가 있다.
* *_PENDING 상태( APPROVAL_PENDING )도 이상 현상을 예방하는 전략 중 하나
* 주문 생성 사가처럼 주문을 업데이트하는 사가는 일단 주문을 *_PENDING 상태로 두고 시작합니다.
* 현재 주문을 사가로 업데이트 하는 중이니 그에 맞게 행동하라고 다른 사가에게 알리는 것
* 시멘틱 락 대책

용어

* 시맨틱 락 semantic lock: 어플리케이션 수준의 락
* 교환적 업데이트 commutative updates : 업데이트 작업은 어떤 순서로 실행해도 되게끔 설계한다.
* 비관적 관점 Pessimistic view : 사가 단계 순서를 재조정하여 비지니스 리스크를 최소화한다.
* 값 다시 읽기 Reread value: 데이터를 덮어 쓸 때 그 전에 변경된 내용은 없는지 값을 다시 읽고 확인하여 더티쓰기를 방지합니다.
* 버전 파일 version file: 순서를 재조정 할 수 있게 업데이트를 기록합니다.
* 값에의한 by value - 요청별 비지니스 위험성을 기준으로 동시성 메커니즘을 동적 선택




























## 1.1 모놀리식 지옥

FTGO 애플리케이션

* 소비자가 웹 / 앱에 접속해서 인근 음식점에 주문하면 배달해주는거
* 배달원과 음식점에 대금을 지불해줌
* 음식점은 메뉴를 편집하고 주문을 관리함
* 대금 지블은 스프라이트 메시지 전송은 트윌리오 이메일은 SES를 씀
* WAR파일로 구성된 모놀리스로 개발됨
* 스파게티코드범벅 느려지고....

## 1. FTGO의 아키택쳐

* 육각형 아키텍쳐이다. 
* UI구현 및 외부 시스템 통합을 담당하는 다양한 어뎁터가 비지니스 로직을 감쌈

![image](https://user-images.githubusercontent.com/72075148/134780533-69a8886c-2dbc-4d1d-bf2a-a77a1065ea41.png)

* 논리적으로 모듈화 했지만 WAR 파일 하나로 패키징한다.
* 마치 실행파일 하나, 단일 소스코드 디렉토리 체계로 배포하는 것과 같음

## 2. 모놀리식 아키텍처 장점

* 개발이 간단하다.
* 쉽게 변경 가능 - 빌드/배포 용이
* 테스트가 쉽다
* 배포가 쉽다. - 그냥 복붙하나
* 확장하기 쉽다.. - lb 뒤에 인스턴스 여러개

## 3. 실상

* 시간이 지나면서 거대한 코드가 됨
* 너무 복잡해서 버그 고치기 힘들고 이해가 어려움
* 개발이 더딤
* 커밋부터 배포까지 험난한 여정..? 
* 화갖ㅇ이 어렵다.
* 테스트도 어렵다..등
* 한물간 기술 스택에 발목이 잡힌다.
* 뭐 대충 어렵다는 얘끼

### 1.2 이 책의 대상 독자...

### 1.3 학습 내용..

# 1.4 마이크로서비스 아키텍쳐가 답

* 아키텍쳐는 기능 요건과 무관하게 다 구현 가능함 사실, 하지만 서비스 품질 요건에 영향을 미친다

## 1. 확장 큐브와 마이크로서비스

![image](https://user-images.githubusercontent.com/72075148/134808138-9ba90b75-f1f5-40fc-a359-eae331b4ec24.png)

### X축 확장 - 다중 인스턴스에 분산

* 모놀리식 애플리케이션의 확장 수단
* 로드밸런서 뒤에 인스턴스 N개 띄워 놓고, 분배..

### Z축 확장 - 요청 속성 별 라우팅

* 라우터는 요청 속성에 알맞은 인스턴스로 라우팅 한다 - userId에 따라 ? 이런식
* 인스턴스는 자기에게 배정된 하위 집합만 처리한다.
* 헤더에 포함된 userId를 보고 N개의 동일한 애플리케이션 인스턴스 중 하나를 선택
* 증가하는 트랜잭션 및 데이터 볼륨을 처리하기 좋은 수단

### Y축 확장 - 기능에 따라 애플리케이션을 서비스로 분해

* X-Y는 애플리케이션 능력 / 가용성은 개선이 되지만 복잡해지는 문제는 해결되지 안흔ㄴ다. 따라서 분해가 필요하다.
* 서비스에 따라 X/Z축 확장도 가능



## 2. 모듈성

* 크고 복잡한 애플리케이션을 개발할 때 꼭 필요한 특성
* 한 개인이 전부 다 이해하고 개발할 수 없다. 따라서 여러사람이 이해하고 개발할 수 잇게 여러 모듈로 분해한다.
* 모듈성의 단위로 사용한다. 
* 각 서비스가 함부로 규칙을 어기고 침투하지 못하게 API라는 경계선을 갖고있다
* 시간이 지나도 모듈성을 유지하기 쉽다.
* 독립적으로 배포/확장 할 수 있는 부가적인 장점

## 3. 서비스마다 DB가 따로 있다.

* 서로 다른 디비를 써서 일일히 협의 안하고 본인이 스키마를 변경 가능, 
* 런타임에서 분리가 되어있어서 다른 서비스가 DB락을 획득해 블로킹 하는 일 따위는 없음

## 4. FTGO 마이크로 서비스 아키텍쳐

* 주문 서비스
* 배달 서비스
* 음식점 서비스
* 주방 서비스
* 회계 서비스
* ![image](https://user-images.githubusercontent.com/72075148/134809424-bf8ac0fa-ebbf-474b-8d59-e47909b4a0b1.png)

## 5. SOA

* 서비스 지향 아키텍쳐와 다를 것이 없음 하지만 깊게 들어가면 근본적인 차이점이 있다.

* 서비스 간 통신

  * SOA - SOAP, WS 표준처럼 무거운 프로토콜을 응용한 앤터프라이즈 서비스 버스 중심의 스파트 파이프
  * MSA - REST나 gRPC처럼 가벼운 프로토콜을 응용한 메시지 브로커 또는 서비스 간 통신 중심의 덤 파이프

* 데이터

  * 전역 데이터 모델 및 공유 DB
  * 서비스 개별 데이터 모델 및 DB

  

# 1.5 장단점

## 장점

* 크고 복잡한 애플리케이션을 지속적 전달/배포 가능
* 규모가 작아 관리 쉬움
* 독립적으로 배포/확장 가능
* 팀 운용 쉬움
* 결함 격리가 잘 됨
* 새로운 기술 실험/도입이 쉬움

## 단점

* 딱 맞는 서비스를 찾기가 쉽지 않다.
* 분사 시스템은 복잡하다
* 공통 기능은 배포할 떄 잘 살펴봐야한다
* 도입 시기를 결정하기 어렵다.

# 1.6 마이크로 서비스 아키텍쳐 패턴 언어

* 패턴 포맷으로 기술을 객관적으로 기술하는 것,

### 패턴 및 패턴언어

* 패턴은 특정 상황에서 발생한 문제에 대한 재사용 가능한 해법..
* 마이너스 통장 정책을 지원해야 하는 뱅킹 애플리케이션을 구축한다고 가정,
  * 잔고, 한도, 초과 인출된 수수료 는 은행마다 정책이 다르다. - Strategy Pattern으로 해결이 가능하다.
    * 초과 인출 알고리즘을 캡슐화 한 전략 인터페이스 overdraft
    * 하나 이상의 전략 구상 클래스 - concrete class , 각각 특정 맥락을 표현
    * 알고리즘을 사용하는 Account 클래스

* 패턴은 자신이 적용되는 맥락을 반드시 기술해야하는게 가치가 있다.
  * 어떤 맥락에선 전혀 안통하고, 그런 생각 덕에 더 나은 방법으로 기술을 논할 수 있게 되었다.
* 솔루션의 측면도 함께 기술하도록 강제한다는 점에서 효용성이 크다,.

### 강제 조항 - forces

* 문제 해결을 위해 반드시 처리해야 할 이슈

* 코드는 이해하기 쉬워야하면서 성능도 우수해야한다.

* 리액티브 스타일로 작성한 코드는 동기코드보다 성능은 우수할지 모르겠지만 이해하기는 상대적으로 더 어렵다.

* 강제 조항을 명시적으로 나열하면 어느 이슈를 해결해야 할지 명확해진다

  ㅊ

### 결과 맥락 - resulting context

* 패턴을 적용한 결과를 다음 세 부분으로 기술하는 영역이다.
* 장점 - 해결된 강제 조항 등 
* 단점 - 미해결 강제 조항
* 이슈 - 패턴 적용 시 발생한 새로운 문제점



### 연관 패턴 - related patterns

* 다섯가지 관계 유형
* 선행자 predecessor - 이 패턴을 필요하게 만든 선행 패턴  - msa 패턴은 나머지 패턴들의 선행자임 ( 모놀리식 말고 )
* 후행자 successor - 이 패턴으로 야기된 이슈를 해결하는 패턴 - msa패턴을 적용하려면 서비스 디스커버리 패턴, 서킷브레이커 패턴 등 함께 적용해야함
* 대안 alternative - 이 패턴의 대체 솔루션을 제공하는 패턴 - 모놀리식 / 마이크로서비스 아키텍쳐 패턴 같이
* 일반화 - generailzation - 문제를 해결하는 일반적인 솔루션에 해당하는 패턴
* 세분화 - specializtion - 특정 패턴을 더 세부적으로 나타낸 형태



## 마이크로서비스 아키텍처 패턴 언어 개요

* 인프라 패턴
* 애플리케이션 인프라
* 애플리케이션 패턴

### 어플리케이션을 여러 서비스로 분해하는 패턴

* 2장에서 다룸

### 통신 패턴

* msa에서 IPC가 매우 종요함
* 따라서 어케 통신할지 다양한 관점,의사 결정을 해야한다.
* 통신스타일 - 어떤 종류의 IPC를 사용하는가
* 디스커버리 - 서비스 클라이언트는 서비스 인스턴스의 IP주소를 어떻게 가져오는가
* 신뢰성 - 서비스 불능 시 서비스 간 통신의 신뢰성은 어떻게 보장되는가
* 트랜잭셔널 메시징 - 비지니스 데이터를 업데이트하는 DB트랜잭션에 메시지를 송신하고 이벤트를 발행하는 행위를 어떻게 통합하는가?
* 외부 API - 애플리케이션 클라이언트는 서비스와 어떻게 통신하는가
* 8장에서 설명할꺼

### 트랜잭션 관리를 위한 데이터 일관성 패턴

* DB를 갖고 서로 느슨하게 결합한다고 했지? 
* 하지만 서비스마다 따로두면  기존의 분산 - 트랜잭션은 요즘 애플리케이션에는 안맞는 방법이라 사바패턴에 따라 데이터 일관성을 유지해야함
* 4장~6에서 설명예정

### 데이터 쿼리 패턴

* 서비스마다 DB를 두면 각 서비스가 소유한 데이터를 조인하는 쿼리도 문제임
* 서비스 데이터는 오직 그 서비스의 API로만 접근이 가능하니까 DB에 분산 쿼리를 쓸수없음 따라서 두가지 패턴을 씀
* API조합 패턴은 하나 이상의 서비스를 호출해서 그 결과를 조합하고, CQRS는 하나 이상의 데이터 레플리카를 유지해서 쉽게 쿼리하는 방식
* 7장에서 예정

### 서비스 배포 패턴

* 모놀리식은 배포 하나만 하면 되니까 직관적이고 편함 - 로드밸런서는 물론 두겠지
* 수십 수백개의 서비스로 이뤄지니까 배포작업이 훨씬 더 복잡하고 관리할 가동부가 상당히 많다.
* 12장에서 다룬다

### 관측성 패턴

* 어플리케이션 동작 파악
* 헬스 체크 api - 서비스 헬스를 반환하는 엔드포인트를 expose한다.
* 로그 수집 - 서비스 내역을 기록하고 중앙 로깅 서버에 로그를 출력하여 검색/경고 기능을 제공한다.
* 분산 추적 - 각 외부 요청마다 ID를 부여하여 서비스를 통과하는 과정을 추적한다.
* 예외 추적 - 예외가 발생하면 예외 추적 서비스에 보고한다. 중복된 예외를 걸러내고 개발자에게 경고를 보내거나 그 해결상태를 추적함
* 애플리케이션 지표 - 카운터, 게이지 등의 지표를 측정하여 지표 서버에 표출한다
* audit logging - 사용자가 한 일을 기록한다.
* 11장에서 다룬다.

### 서비스 테스트 자동화 패턴

* 각 서비스를 테스트하는건 쉽지만 다른 서비스와 조화롭게 잘 작동하는지 테스트하는것도 중요함.
* 느리고 복잡한 end to end test는 가급적 피하는게 상택이다.
* 컨슈머 주도 계약 테스트 - 클라이언트가 의도한대로 서비스가 동작하는지 확인한다
* 컨슈머 쪽 계약 테스트 - 클라이언트와 서비스가 상호 통신 가능한지 확인
* 서비스 컴포넌트 테스트 - 서비스를 따로따로 테스트
* 9~10장에서 설명

### 횡단 관심사 처리 패턴

* DB자격증명 같은 구성 매개변수를 런타임 서비스에 제공하는 외부화 구성 패턴을 적용해야한다.
* 이런 cross-cutting concern을 처음부터 다시 개발하면 시간이 너무 많이 걸린다.
* 프레임워크에서 마이크로서비스 섀시 패턴을 적용하는게 더 바람직하다 
* 11장에서 다룸

### 보안 패턴

* 마이크로서비스 아키텍처에서는 일반적으로 API게이트웨이가 identity, role, 등 사용자 정보를 인증한 후 호출할 서비스에 관련 정보를 전달함
* JWT, AccessToken을 적용한다.
* 이거확인하고 조회함

# 7 프로세스와 조직

* 크기가 N인 팀의 소통 오버헤드는 O(n^2)으로 증가한다고 한다.
* 팀이 너무 커지면 소통 오버헤드가 급격히 증가하여 운영 효율이 떨어진다.
* 아침마다 20명씩 스탠드업 미팅을 한다?
* 팀은 8~12명 정도가 좋다.
* 어떤 기능이나 비지니스 능력이 구현된 하나 이상으 ㅣ서비스를 개발/운영 하는게 목적이지?
* 범기능 팀을 구성하면 매번 다른팀하고 소통하거나 협의 안해도, 서비스를 독자적으로 개발 테스트 배포 가능함
* 개발하는 조직도 애플리케이션 아키텍처 처럼 조직의 구조가 고대로 반영되어야한다는거
* 거대한 한 팀보다 작은 여러 팀의 움직임이 더 빠르다.

### 소프트웨어 개발/전달 프로세스

* msa 는 애자일, 스크럼, 칸반을 실천해야한다. CI/CD를 실천해야한다.
* 지속 전달으 ㅣ핵심은 소프트웨어를 언제든 릴리즈 할 수 있는 능력이다.
* 따라서 자동화 테스트 등 높은 수준의 자동화는 필수이다.

### 소프트웨어 개발 수준을 평가하는 잣대

* 배포 빈도
* 리드타임 - 개발자가 변경분을 체크인할 때 부터 프로덕션 배포할 때까지 걸린 시간
* 평균 복구 시간 Mean Time To Recover - 프로덕션 문제 복구에 소요된 시간
* 변경분 실패율 - 프로덕션에 문제를 일으킨 변경부의 비율 %

예전에는 배포는 가끔하고 리드타임은 긴 조직이 많았다.

아마존은 11.6초당 한 번씩 프로덕션에 뼌경분을 배포하고 넷플은 소프트웨어 컴포넌트당 리드타임이 16분이다.

## 인간적인 요소

...

# 8 마치며

* 모놀리식 아키텍처 패턴은 애플리케이션을 하나의 배포 단위로 구성한다
* msa는 독립적으로 배포 가능하고 자체 db를 보유한 서비스들로 시스템을 분해한다.
* 단순한 애플리케이션은 모놀리식, 크고 복잡한건 마이크로 서비스 아키텍쳐가 더 적합한 선택
* 마이크로서비스 아키텍처를 채택하면 자율적인 소규모 팀들이 작업을 병행할 수 있어서 개발 속도가 빠르다
* 만병통치약은 아님 복잡성을 비록해서 중요한 단점도 있음
* 패턴언어는 유용한 패턴들의 모음집이고, 도입 여부를 결정 시 유용하고 효과적으로 적용하는 충실한 안내자
* 소프트웨어 전달 속도를 높이려면 msa만으로는 부족함, 성공적으로 개발하려면 데브옵스 및 자율적인 소규모 팀들이 있어야함
* ~_~
* 








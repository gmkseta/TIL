# 엔지니어링

# 코드 기능 명세

1. 충분히 명확한 도메인 지식을 확보하지 못한 프로그래머는 지식 보강 요청을 해야함
2. 잘알고 잘 작성해야한다...

# 테스트 기법

## 수동 테스트

* QA담당자가 UI를 사용해 기능을 검증
* 인수 테스트 - 클라이언트가 인수할 때..
* 실행하는 비용이 높고 결과의 변동이 크다.

## 소프트웨어 회귀

* 새로운 기능이 추가 될 수록 기존 기능이 오작동
* 새 기능만 테스트하면 안댐 기존의 기능을 테스트해야함
* 수동테스트 만으로 감당이 

## 테스트 자동화

1. 기능을 검증하는 코드를 작성
2. 테스트 코드 작성 비용이 소비되지만 실행 비용이 낮고 결과의 신뢰도가 높음
3. 프로그래머 역량에 크게 영향 받음

## 인수 테스트

* 신뢰도가 높음
* 높은 비용
* 피드백 품질이 낮음

## 단위 테스트

* 시스템 일부를 ㄷㅐ상
* 낮은 ㅂㅣ용
* 높은 피드백 품질
* 전체 시스템 ㅇㅣ상 신뢰도가 낮음

# 코드 분해

* 시스템의 크기는 점점 커지고
* 큰 문제는 작은 문제로 분해할 수 있다.
* 작은 문제의 일부는 반복된다.
* 재사용이 가능하다.
* 소프트웨어 개발 비용 절감

## 모듈화

### 분해

* 큰 시스템은 더 작은 하위 시스템으로 분해 가능하다.
* 교체 가능

### 조립

* 작은 시스템은 더 큰 상위 시스템으로 조립 가능
* 모듈 재사용
* 라이브러리

### 단위 테스트

* 해볼게 없는디
* parametrize test



## 테스트 우선 개발

### 운영 코드보다 테스트 코드를 먼저 작성

1. 명확하고  검증 가능한 목표를 설정한 후 목표를 달성
2. 프로세스가 코딩에 앞선 목표 설정을 강요
3. 프로그래머는 자신이 풀어야 할 문제를 구체적으로 이해해야함

실습은 흠 ;;

## Refactoring

* 생산성 - 생산성의 차이
* 지속성 - 작업 환경의 생산성이 일정 수준 미만으로 떨어지면 더 이상 그 환경에서 작업 진행 불가능
* 의미를 유지하며 코드 베이스를 정리 -> 의미 유지를 어떻게 확인할 것 인가?

# TDD

Red - 실패하는 테스트

Green - 테스트 통과 - 최소한의 코딩

Refactor - 구현 설계 개선, 테스트 통과 유지

## 테스트 성공 

1. 추가된 테스트를 비록해 모든 테스트가 성공하도록 **운영 코드를 변경**
2. 테스트 성공은 요구사항 만족을 의미 - 코딩의 가장 중요한 임무
3. 테스트 성공을 위한 최소한의 변경 - 가장 중요한 임무를 가장 빠르게 완수

## 리펙터링

* 코드베이스 정리
* 구현 설계 개선
  * 가독성 
  * 적응성
  * 성능
* 모든 테스트 성공을 전제

## 켄트 벡의 설계 규칙

* passes the test
* Reveals intention
  * 의도를 노출해라
* No duplication
* Fewest elements
  * 테스트에 필요없는건 안넣어



단위테스트 작성 - 테스트 실행 - 운영코드 작성 - 단위테스트 실행 - 설계 개선 - 단위테스트 실행 -

![image](https://user-images.githubusercontent.com/72075148/136387161-e58500a6-27ea-4943-8dda-75cd3f240ca0.png)

* 만약 TDD비용을 낮추면?
* 풍부한 테스트 도구는 테스트코드가 도메인 지식 표현에 집중하도록 응집도와 가독성을 높임
* refiner 에서 앞에 비는걸 해봤다.






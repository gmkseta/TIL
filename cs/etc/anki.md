
## OAuth 란

* OAuth 는 사용자들이 비밀번호를 제공하지 않고 웹 서비스나 애플리케이션의 인증이나 접근 위임을 위한 표준

* Authorization Code - access token를 발급받을 수 있는 코드
* Implicit Grant - 바로 access token을 발급 받는 방법 
  * Resource Owner 없이 발급 가능하므로 , 기한을 짧게..
* Resource Owner Password Credentials
  * 유저의 아이디, 비밀번호가 access token을 얻기위한 Authorization grant로 사용된다.
  * 매우 취약 신뢰 가능한 클라이언트만
* client credenital -> client == resource owner인 경우 일반적인 소셜 로그인이 아닌 백엔드에서


## MSA

**하나의 어플리케이션을 이루는 서비스들을 기능, 도메인 단위로 쪼개서 구축하는 것을 말합니다.**

디플로이, 확장, 장애 관점

- 모놀로직에서의 단점을 극복하고자 나왔다
    - 특정 부분, 기능의 장애가 전체 서비스의 장애로 확대될 수 있다. 트래픽이 몰렸을때나..
    - 여러 컴포넌트가 하나의 서비스에 구현 되어있으므로 강하게 결합이 되어있어서 커졌을때 수정이 쉽지않다.
    - 배포시간이 오래걸린다.
    - 한 언어, 프레임워크에 종속적이다.

서로 독립적인 서비스면 ? 장애 굿 개별적으로 배포가능, 개별적으로 scale out, 여러 언어,

단점

- 모놀로식에 비해 상대적으로 많이 복잡한, 서비스가 각각 독립된 데이터베이스를 갖고있어서
    - 일관성을 어떻게 유지할지 transaction에 대해 고민을 많이 해봐야한다.
    - 데이터 관리에 정합성...
- 레이턴시가 늘어난다.

## HTTP vs HTTPS

* http는 네트워크에서 데이터를 주고받을 수 있는 프로토콜이다. 암호화 되지 않은 상태로 데이터를 주고받기 때문에 보안취약점이 있어서 ssl/tls 보안 레이어를 추가한 것이 https 데이터를 주고받을 때 암호화를 해서 중간에 누가 가로채도 보안상 문제가 없다.

## SSL / TLS

* Application Layer와 Transport Layer 사이에서 암호화 복호화를 해주는 계층
* 보안 통신을 하기위한 프로토콜이다.
* HTTPS뿐만 아니라 FTP, SMTP같은 프로토콜에서도 씀
* 서버와 클라이언트의 신원을 확인하는 데는 인증서가 사용된다.

## 공개키 방식

* 공개키 암호화 방식과 서명 방식

### 대칭키 방식

* 키가 많다 , 키 관리를 많이 해야한다.
* 10개 끼리 

### 공개키 방식



## JWToken



## google.com 치면 일어나는 일

* DNS를 통해서 서버의 ip를 요청한다.
* 로컬DNS 즉 캐시에 없으면 ISP의 DNS서버에서 얻어온다.
* IP를 받았으면 ARP를 통해서 mac주소를 얻어온다.
* 브라우저가 해당 서버와 TCP연결을 시작한다.
* 브라우저가 웹 서버에 HTTP요청을 보낸다.
* 서버가 HTTP응답을 보낸다.
* https라면 tls과정이 추가된다.

https://hahahoho5915.tistory.com/15

https://goldfishhead.tistory.com/23

## CORS

## TCP vs UDP

* TCP - 연결 지향형 프로토콜, 바이트 스트림을 통한 연결, 혼잡 제어, 흐름 제어, 순서 보장, 느림, 신뢰성 있는 데이터 전송
* UDP - 비 연결 지향형 프로토콜, 메시지 스트림 연결, 순서 보장 안됨, 빠름, 

## TCP 3 way handshake

* 

## DNS

- www.example.com과 같이 사람이 읽을 수 있는 이름을 192.0.2.1과 같은 숫자 IP 주소로 변환하여 컴퓨터가 서로 통신할 수 있도록 한다. 
- 인터넷의 DNS 시스템은 이름과 숫자 간의 매핑을 관리하여 마치 전화번호부와 같은 기능
- DNS 서버는 이름에 대한 요청을 IP 주소로 변환하여 최종 사용자가 도메인 이름을 웹 브라우저에 입력할 때 해당 사용자를 어떤 서버에 연결할 것인지를 제어한다. 이 요청을 쿼리라고 한다.

https://pinelover.tistory.com/180

## 프록시 서버, 리버스 프록시

통신을 할 때 직접 하지 않고 중간에서 대리로 통신을 하는 것을 **'프록시'**라고 하고, 중계 역할을 하는 것을 **'프록시 서버'** 라고 부른다. 즉, 클라이언트와 서버 사이의 **'중계 서버'**라고 생각하면 된다. 프록시 서버는 보안 목적이나 캐싱 등의 기능을 제공한다.

프록시 서버가 중간에 위치함으로써 **클라이언트는 프록시 서버를 '서버'**라고 인식하고, **서버 입장에서는 프록시 서버를 '클라이언트'**로 인식하게 된다.

## 쿠키, 세션

쿠키란?

- 쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일입니다.
- 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있습니다.
- 쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조합니다.
- 클라이언트에 300개까지 쿠키저장 가능, 하나의 도메인당 20개의 값만 가질 수 있음, 하나의 쿠키값은 4KB까지 저장합니다.
- Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있습니다.
- 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송합니다.

쿠키의 구성 요소

- 이름 : 각각의 쿠키를 구별하는 데 사용되는 이름
- 값 : 쿠키의 이름과 관련된 값
- 유효시간 : 쿠키의 유지시간
- 도메인 : 쿠키를 전송할 도메인
- 경로 : 쿠키를 전송할 요청 경로

쿠키의 동작 방식

1. 클라이언트가 페이지를 요청
2. 서버에서 쿠키를 생성
3. HTTP 헤더에 쿠키를 포함 시켜 응답
4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음
5. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄

세션이란?

- 세션은 쿠키를 기반하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리합니다.
- 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지합니다.
- 물론 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능 합니다.
- 사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지하게 됩니다.
- 즉 동접자 수가 많은 웹 사이트인 경우 서버에 과부하를 주게 되므로 성능 저하의 요인이 됩니다.
- 클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는 데 이것이 세션 ID입니다.

세션의 동작 방식

1. 클라이언트가 서버에 접속 시 세션 ID를 발급 받음
2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있음
3. 클라리언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청
4. 서버는 세션 ID를 전달 받아서 별다른 작업없이 세션 ID로 세션에 있는 클라언트 정보를 가져와서 사용
5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답

세션의 특징

- 각 클라이언트에게 고유 ID를 부여
- 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
- 보안 면에서 쿠키보다 우수
- 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨

세션의 사용 예

- 로그인 같이 보안상 중요한 작업을 수행할 때 사용

https://interconnection.tistory.com/74

## Connection-Oriented and Connectionless  - Services

* 서비스라는 것은? 아래 레이어가 위에게 제공하는거죠

### CO service

* 전화을 본떠서 모델링 되었다.
* 세 단계로 - 연결 설정, 데이터 전송, 릴리즈
* 패킷들이 보낸 순서대로 도착한다.

### CL service

* 우편 시스템을 본떠서 모델링됨 - 일명 데이터그램 서비스
* 셋업이 필요 없다.
* 순서가 보장되지 않는다.

### 신뢰성 - Reliability

* CO인지 CL에 따라 신뢰성 차이가 나는 것이 아닌
  * acknowledged , unacknowledged  - 답신을 받느냐 아니냐 차이
* 신뢰성 없는 서비스는 빠른 전송이 필요할 때 - 리얼타임 어플리케이션, 몇개 패킷은 잃어도 될 때

Message Sequence vs Byte Stream

- 메시지 시퀀스에서 메시지는 보존됨, 전송중에 쪼개지거나 합쳐지지 않음

* 바이트 스트림에서는 그냥 바이트 단위로 물흐르듯....?



혼잡제어?

* 패킷양이 많아지면 .. 멈추니까 감지해서 전송을 좀 늦추는

흐름제어?

* 네트워크 - 오케이

TCP 헤더안에 수신자의 버퍼 크기를 



UDP를 쓴다?

* 속도빠르다. 스트리밍같은거 할때 - 실시간성이 중요할때 







## HTTP1.0 / 1.1 / 2.0 / 3.0

### HTTP 1.0

* Connection당 하나의 요청을 처리한다.
* 동시 전송이 불가능하고 하나의 요청에 대한 응답이 온 뒤 다음 요청을 처리한다.
* 따라서 느리다

### HTTP 1.1

* HTTP Pipelining을 도입하여 TCP안에 두 개 이상의 HTTP 요청을 담아 레이턴시를 줄인다.
* Head of Line Blocking 문제가 있다.
  * 앞에 요청한 응답이 지연되면 뒤의 요청도 지연된다.
* 서버는 받은 순서대로 응답한다.
* 헤더를 계속 중복해서 보낸다,.

### HTTP 2.0

* 하나의 connection으로 동시에 여러개의 메시지를 주고 받을 수 있다.
* 요청 순서와 관계없이 stream으로 받기 때문에 HOL Blocking도 발생하지 않는다.
* 중복되는 header를 보내지 않고 변경되는 값만 보낸다. HPACK 압축도 한다.

### HTTP 3.0

* TCP Handshaking이 필요없다.
* QUIC 3 way Handshaking 한번만 하고, 두 번쨰 연결시도 부터는 기존 연결의 connection id와 메타 데이터를 그대로 사용
* 패킷 손실 감지에 걸리는 시간을 단축해서 혼잡제어를 개선했다. - RTT
* 멀티플랙싱

## 혼잡제어

* 네트워크의 처리 속도 차이 해결을 위한 
* 송신측

## 흐름제어

* 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법

## HAProxy

## Select for update랑 Redis setnx

* 재고처리
* 1000원 이벤트
* 디비락

## Unique index 겹친다



## DB INDEX

## B Tree

* 이진트리에서 발전되어 모든 리프 노드들이 같은 레벨을 가질 수 있도록 자동으로 균형을 맞추는 트리이다.
* 검색 속도가 O(logn), 정렬된 순서를 보장하고, 
* 순차 탐색시 중위 순회 하느라 비 효율적 - 재귀

## B+Tree

* 리프에 데이터를 저장하는 트리
* 리프가 아닌 노드는 포인터만 제공
* 리프가 연결리스트로 연결이 되어있어서 순차 접근이 쉽다.

## Hash Index

* 

## Unique index

* 

## postgreSQL

* Schema이라는 데이터베이스를 논리적으로 분리하는 단위가 있고
* ~~update하기 위해 , insert하고 원래 있던 행을 삭제표시한대~~
* mysql 은 멀티 스레드고, postgres multiprocess라는데 이것떄문인지는 모르겠지만 세션당 메모리 사용량인 postgres가 더 높아서 connection pool이 더 제한적이다.
* Postgresql에서는 vacuum이라는 작업을 해야해서 오버헤드가 크다. - sql성능이나 파일 크기가 불안정
* 대량 insert가 postgresql이 더 낫다.

## Table

* unique index vs unique
  * 거의 동일하다.
  * 고유 인덱스 생성함
* Regarding replication, ALTER TABLE will be transmitted through the replication process in a fully consistent manner.



## 기술적인 측면으로 자기소개

* 동시성 적인 측면에서의 에러나, 

## SETNX

* 



## Socket.io

기본적으로 Socket.io는 클라이언트에서 직접적으로 커넥션을 연결해주고, 그 연결된 커넥션으로 서버에서 메세지를 받고 보내는 동작을 한다.

문제는 서버를 구축시 대부분의 이벤트가 하나의 클라이언트가 다른 모든 클라이언트에게 메세지를 보내는 브로드캐스팅이 대부분이라는 것이다. 만약 서버가 여러대 일경우 모든클라이언트에게 전달이 되는것이 아닌 같은 서버와 커넥션이 연결된 클라이언트에게만 이벤트가 전달되고 다른서버와 연결된 클라이언트에게는 전달이 되지 않는 문제가 생긴다.

## 해결 방안

이 문제를 해결하기 위해서는 이벤트가 발생시 이 이벤트를 다른 서버에 전파를 해줘야하는데 이 부분에서 가장 간단하면서 빠른 방법은 redis를 이용하여 Socket서버간 Pub/Sub해주는 게 좋아 보였다.

이와 관련된 redis를 찾아보니, [socket.io-redis](https://github.com/socketio/socket.io-redis) 라는 라이브러리가 있어서 사용을 하니 매우 간단하게 redis를 이용하여 Socket 서버간 전파가 가능했다.



## 객체 지향 4대 원칙

### 상속

- 하위 클래스 - 상위 클래스
  - 하위클래스 `is a kind of` 상위클래스
  - 하위 클래스는 상위클래스 특성을 **재사용**하고, **확장**한다.
  - 상위 클래스의 물려줄 특성이 많을수록 좋다 (LSP)
    - 상위 클래스가 너무 빈약하면, 불필요한 형변환이 자주 일어난다.
- 인터페이스
  - 다중 상속 대신 도입
  - 어떤 객체가 **해야할 일**을 정의하는 **추상** 자료형
  - 구현 클래스 `is able to` 인터페이스 (ex. `Runnable`)
  - 인터 페이스는 구현을 강제할 메서드가 적을수록 좋다 (ISP)

### 추상화

- 클래스 VS 객체
  - **클래스** : 분류에 대한 **개념** -> 같은 특성을 지닌 여러 객체를 총칭하는 집합의 개념 (ex.사람)
  - **객체** : **실체** -> 유일무이한 사물 (ex. 김연아)
- 추상화
  : 구체적인 것을 분해해서 **관심 영역 (애플리케이션 경계)** 에 있는 특성만 가지고 재조합하는 것 (= 모델링)
















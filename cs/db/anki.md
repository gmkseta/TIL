## 데이터베이스를 사용하는 이유?

- 데이터베이스가 존재하기 이전에는 파일시스템으로 관리
  - 현재도 부분적으로 사용
- OS에 종속적인 파일시스템은 프로그램의 확장성을 해친다.
- 데이터 중복, 비일관성, 검색등의 문제
  - 중복 최소화, 보안성, 계속적 변화에 대한 적응
- DB는 원자적 갱신, 동시성 제어, 데이터 보호, 백업 및 회복 등의 여러 기능

## 데이터베이스의 특징

1. 독립성
2. 무결정
3. 보안성
4. 일관성
5. 중복 최소화

## 데이터의 독립성

- 물리적 독립성

  - 디비의 사이즈를 늘리건

- 논리적 독립성

## ACID에 대해 설명해주세요.

- ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질
- 데이터의 유효성을 보장하기 위한 트랜잭션의 특징
- Atomicity (원자성)
  - 트랜잭션은 분해가 불가능한 최소의 단위인 하나의 원자처럼 동작한다는 의미
  - 트랜잭션의 연산은 모든 연산이 완벽하게 수행 되어야한다
  - 한 연산이라도 실패하면 트랜잭션은 실패해야한다.
  - 모든 작업이 반영되거나 모두 반영이 안되거나
- Consistency ( 일관성 )
  - 트랜잭션은 유효한 상태로만 변경될 수 있다.
  - 데이터는 미리 정의된 규칙에서만 수정이 가능한 특성
  - 외래키 관계 유지 등
- Isolation ( 고립성 )
  - 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향 없이 독립적으로 실행
  - 두 개 이상의 트랜잭션이 동시에 발생하면 서로 영향이 없어야함
  - Lock으로 보장한다.
- Durability( 내구성 )
  - 트랜잭션이 커밋된 이후에는 시스템 오류가 발생하더라도 커밋된 상태로 유지되는 것을 보장
  - 한 번 반영(커밋)된 트랜잭션의 내용은 영원히 적용된다.

## 트랜잭션이 뭔가요?

- 데이터베이스의 상태를 변화시키는 하나의 원자적인 논리 작업 단위, DB의 일관된 상태를 또 다른 일관된 상태로 변환시키는 기능

## 트랜잭션의 상태

* 활동 Active
  * 트랜잭션이 실행 중에 있는 상태, 정상적으로 실행중
* 장애 Failed
  * 트랜잭션이 실행에 오류가 발생하여 중단된 상태
* 철회 Aborted
  * 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
* 부분 완료 Partially Committed
  * 마지막 연산까지 실행했지만 아직 commit 직전
* 완료 Committed
  * 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태



## 트랜잭션의 격리 수준 - Transaction Isolation Levels

- 동시에 여러 트랜잭션이 처리될 때
- 특정 트랜잭션이 다른 트랜잭션에서 변경/조회하는 데이터에 대한 접근 권한 수준을 결정
- 고립도와 성능의 트레이드 오프를 조절한다.
- 트랜잭션에서 일관성 없는 데이터를 허용하는 수준

### lv 0 - Read Uncommitted

- 아직 커밋되지 않은 데이터를 읽는다.
- 일관성 유지가 거의 불가능하다.
- DirtyRead문제 발생 가능 - 커밋 전에 읽어서 롤백되면? 달라짐

### lv 1 - Read Committed

- 다른 트랜잭션에서 커밋된 내용만 읽을 수 있다.
- postgresql의 default 고립화 수준
- 쿼리가 시작되기 전 다른 트랜잭션에서 commit된 결과를 참조한다.
- 트랜잭션 내에서 같은 select을 실행해도 다른 트랜잭션의 commit 여부에 따라 다른 결과
  - Phantom Read - insert 또는 delete으로 인한 새로운 행 때문에 다른 값?
  - Non-repeatable Read - update 때문에 다른 값


### lv 2 - Repeatable Read

* 트랜잭션이 시작되기 전 ocmmit된 결과만 참조 가능
* 잠금 기반 동시성 제어 DBMS는 읽기 및 쓰기 잠금을 유지한다, 하지만 범위 잠금은 안되므로 phantom read
  * Non-repeatable Read는 발생 안하지만 phantom read는 여전히, 허용됨
* mysql에선 트랜잭션마다 id를 부여해서 더 작은 트랜잭션 번호에서 변경한것만
  * psql에서는 .. phantom read상황에서 오류 발생하곤 한다..?

### lv 3 - Serializable

* 가장 업격한 격리 수준
* 한 트랜잭션이 테이블을 읽으면 ㄷㅏ른 트랜잭션은 그 테이블에 대해 추가/변경/삭제가 불가능
* 말그대로 직렬화해서
* 동시성 성능이 너무 떨어진다.

https://www.postgresql.kr/blog/pg_phantom_read.html

## 무결성에 대해 얘기해보세요.

A. 무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말한다. 데이터의 무결성을 유지하기 위해 DBMS에서는 크게 4가지 종류로 구분한다.

- 개체 무결성 : 기본키로 선택된 필드는 빈 값을 허용하지 않는다.
- 참조 무결성 : 서로 참조 관계에잇는 두 테이블의 데이터는 항상 일관된 값을 유지한다.
- 도메인 무결성 : 테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로 올바른 데이터가 입력됬는지를 체크하는 것이다.
- 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성값은 모두 고유한 값을 가진다. 같으면 안된는 것
- NULL 무결성 : 특정 속성값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성값은 NULL이 될 수 없다는 제약조건
- 키 무결성 : 한 릴레이션에는 최소한 하나의 키가 존재해야하는 제약조건

## 무결성을 유지하려는 이유가 무엇인가요?

A. 무결성이 유지가 되어야 DB에 저장된 데이터 값과 거기에 해당하는 현실 세계의 실제값이 일치하는지 신뢰할 수 있기 때문이다.



## 트랜잭션을 병행으로 처리하려고 할 때 발생할 수 있는 문제를 설명해보시오.

- 갱신 내용 손실 : 동시에 하나의 데이터가 갱신될 때 하나의 갱신이 누락되는 경우
- 현황 파악 오류 : 하나의 데이터 갱신이 끝나지 않은 시점에서 다른 트랜잭션이 해당 데이터를 조회하는 경우
- 모순성 : 두 트랜잭션이 동시에 실행될 때 데이터베이스가 일관성이 없는 모순된 상태로 남는 문제
- 연쇄 복귀 : 두 트랜잭션이 하나의 레코드를 갱신할 때 하나의 트랜잭션이 롤백하면 다른 하나의 트랜잭션 마저 롤백이 되는 문제

## 트랜잭션을 병행으로 처리할 때 위와 같은 문제를 방지하기 위한 방법을 설명하시오.

* 로킹 제어 기법을 사용한다.
* 어떤 트랜잭션이 특정 DB의 데이터를 사용할 때 DB의 일정부분을 Lock시키고 트랜잭션이 완료될때 해당부분을 Unlock시키는 방법이다. 
* 종류는 크게 두가지가 있는데 공유 로킹은 Lock한 부분을 읽기는 가능하지만 쓰기는 불가능한 것이고 배타 로킹은 읽기,쓰기 둘다 불가능하게 한 것이다.

## 그렇다면 이 로킹 단위를 크게했을 때와 작게 했을 때의 차이점을 설명하시오.

* 로킹 단위가 크면 그만큼 관리가 쉽지만 병행성이 떨어진다. 
* 로킹단위가 작으면 관리가 어렵고 오버헤드가 증가하지만, 병행성이 올라간다.

## 로킹 제어가 일으킬 수 있는 문제점은 무엇인가?

* 로킹단위에 따라 다르겠지만 트랜잭션의 직렬화 가능성이 높아진다.(병행처리하나마나 할 수도있다.) 또 데드락이 발생할 수 있다.

## 데드락에 대해서 설명해보세요.

T1 : write(A) read(B)

T2 : read(B) read(A)

위와 같은 트랜잭션이 있다고 하면 T1은 A를 로킹해두고 B의 로킹해제를 기다려야하고 T2는 B를 로킹해두고 A를 기다려야한다. 

이 때 두 트랜잭션이 무한정 대기해야하는 상황이 발생하는데 이것을 데드락이라고 한다. 

(해결방법 : 이 경우 T1, T2중 하나를 ROLLBACK하고 나머지 하나를 완료시킨 후 ROLLBACK한 트랜잭션을 다시 실행시킨다.)

## 그럼 데드락을 안 생기게 하는 방법을 설명해보시오.

서비스 별로 해결하는 방법이 매우 다른데 일반적으로는 데드락 탐지나 회피를 적용시키면 된다.

탐지인 경우 알고리즘을 통해 매번 데드락인지 아닌지 검사를 해야하므로 코스트가 크다.

회피인 경우 시분할 처리를하여 T1이 끝나면 T2가 실행시키게도 하면된다.

Facebook 처럼 write 보다 read가 월등히 많은 경우 Read용 DB를 slave로 두고 로드를 모두 몰아주고 write를 Master로 보내고 DB를 동기화 할 수도 있다.

또 다른 해결기법으론 로킹 제어기법이 아닌 타임스탬프 기법을 사용한다. 트랜잭션의 식별자로 타임스탬프를 지정하며 순서를 미리 선택한다. 트랜잭션이 대기하지 않고 바로 실행은 하나 높은 확률로 ROLLBACK이 일어나며 연쇄 복귀를 초래할 수 있다.

## COMMIT과 ROLLBACK에 대해 설명해보세요.

COMMIT은 해당 트랜잭션으로 반영된 DB 변경사항을 ***저장\*** 하는 것이고 ROLLBACK은 해당 트랜잭션으로 반영된 DB 변경사항을 ***취소\*** 하는 것이고

## 정규화의 목적이 무엇인가요?

데이터의 중복을 최소화하고 테이블의 삽입, 삭제, 갱신 과정에서 발생하는 이상현상을 방지하기 위함입니다.

## 각 정규화 단계를 설명해보세요.

- 제 1정규화 : 각 컬럼들은 값이 원자값을 가지게 바꾼다.
- 제 2정규화 : 테이블의 모든 컬럼에서 부분 함수적 종속을 제거하는 것
- 제 3정규화 : 기본키를 제외한 속성들 간의 이행적 함수 종속을 없애는 것
- 제 BCNF화 : 결정자이면서 후보키가 아닌 것들 제거
- 제 4정규화 : 다치 종속 제거

## 함수적 종속에 대해서 설명하세요.

테이블 속성들간의 관계에 대한 제약조건으로 속성A가 속성B를 결정할 때 B는 A에 함수적으로 종속된다고 한다.

## 완전함수적 종속에 대하여 설멍하세요.

완전함수적 종속 : 속성들의 집합 X에 대해 Y가 함수적으로 종소될 때, X의 부분집합에 대하여서는 함수적으로 종속되지 않는 경우 Y는 X에 대하여 완전 함수적 종속이라고 한다.

## 역정규화를 하는 이유는 무엇인가요?

정규화를 진행할 수록 하나의 테이블을 여러 테이블로 나누게 되는데, 만약 데이터 호출 시 여러 테이블을 불러서 JOIN을 해줘야한다면 이 비용도 만만치 않기 때문에 역정규화를 한다.

## 데이터베이스 장애에 대해 설명하시오.

- 트랜잭션 장애 : 트랜잭션을 정상적으로 완료하지 못함
- 시스템 장애 : 하드웨어, 소프트웨어 고장으로 인한 장애
- 디스크 장애 : 디스크 스토리지 일부 혹은 전체 붕괴로 인한 장애

## 데이터베이스 회복 기법에 대해 설명하시오.

- 로그기반 회복기법
- 지연 갱신 회복 기법
  - write 연산 지연, 로그에 DB변경 내역 저장
  - 트랜잭션 완료시 로그를 보고 write 연산 수행
  - 트랜잭션 완료시 장애 발생 : REDO만 실행
  - 트랜잭션 미완료시 장애 발생 : 로그 무시
- 즉시 갱신 회복 기법
  - 즉시 DB 변경, 로그에 기록
  - 장애 발생 시 로그에 기반하여 UNDO 실행
- 체크포인트 회복기법
- 체크 포인트를 지정하여 장애발생시 체크포인트까지 UNDO 실행 후 다시 REDO 실행
- 그림자 페이징 회복 기법
- 하드디스크에 그림자 페이지를 만들고 저장해두고 장애발생시 하드디스크에 있는 페이지로 주메모리 페이지 변경
- 장애 미발생시 그림자 페이지 테이블은 삭제

## 관계형 데이터베이스와 비 관계형 데이터베이스 차이점에 대해 설명해보세요.

A. 관계형 데이터베이스란 테이블(table)로 이루어져 있으며, 이 테이블은 키(key)와 값(value)의 관계를 나타낸다.이처럼 데이터의 종속성을 관계(relationship)로 표현하는 것이 관계형 데이터베이스의 특징이다.

비 관계형 데이터베이스는 행과 열로 이루어진 테이블 형식 스키마를 사용하지 않는 데이터베이스이다. 저장되는 데이터 형식의 특정 요구 사항에 맞게 최적화된 저장소 모델을 사용하는 것이 특징이다. 흔히들 NoSQL(not only SQL)이라고 하며 데이터를 저장할 때 SQL문이 아닌 다른 프로그래밍 언어 및 구문을 사용한다.

## RDBMS과 비교하였을 때 NoSQL의 장점을 설명해보세요.

A. 가장 큰 장점이라면 JOIN 처리가 없기 때문에 스케일 아웃을 통한 노드 확장 용이하다는 점이다. 뿐만아니라 가변적인 데이터구조로 데이터를 저장할 수 있어서 훨씬 더 유연성이 높다. 단점으로는 다양하고 복잡한 쿼리가 불가능하고 일관성을 항상 보장할 수 없는 것을 꼽을 수 있다.

속도적인 측면에서는 대표적인 RDBMS인 MySQL이나 ORCLE이 워낙 최적화가 잘 되어있기도하고 주어진 상황에 따라 아주 케이스바이케이스라 뭐가 더 좋다라고는 하기 어렵다.

## 어떤상황에서 NoSQL을 쓰는 것이 더 적합한가?

A. 비정형 데이터를 저장해야할 때 가장 적합하다. 검색기능이 있을 때도 좋다고들하는데 의견이 분분하다. 케바케라는 말이 적절할 것 같다.



## 관계형 데이터베이스의 구성요소

## MVCC or MCC

## 스냅샷격리

## 파티셔닝이란

## ORM이란

## Index란

## B-tree 알고리즘









